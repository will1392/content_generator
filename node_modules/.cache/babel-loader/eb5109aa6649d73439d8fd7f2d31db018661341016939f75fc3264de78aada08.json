{"ast":null,"code":"import { supabase } from './supabase.service';\nexport class ClientService {\n  // Client Management\n  async createClient(clientData) {\n    try {\n      console.log('Attempting to create client:', clientData);\n\n      // First, check if the clients table exists by trying to read from it\n      const {\n        error: tableCheckError\n      } = await supabase.from('clients').select('id').limit(1);\n      if (tableCheckError) {\n        console.error('Clients table does not exist or is not accessible:', tableCheckError);\n\n        // Try to create the table if it doesn't exist\n        await this.createTablesIfNotExist();\n      }\n      const {\n        data,\n        error\n      } = await supabase.from('clients').insert([clientData]).select().single();\n      if (error) {\n        console.error('Supabase insert error:', error);\n        throw error;\n      }\n      console.log('Client created successfully:', data);\n      return data;\n    } catch (error) {\n      console.error('Error creating client:', error);\n      console.error('Error details:', {\n        message: error.message,\n        details: error.details,\n        hint: error.hint,\n        code: error.code\n      });\n      throw new Error(`Failed to create client: ${error.message}`);\n    }\n  }\n\n  // Helper method to create tables if they don't exist\n  async createTablesIfNotExist() {\n    try {\n      console.log('Attempting to create tables...');\n\n      // Create clients table\n      const {\n        error: clientsError\n      } = await supabase.rpc('exec_sql', {\n        sql: `\n          CREATE TABLE IF NOT EXISTS clients (\n            id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            email VARCHAR(255),\n            company VARCHAR(255),\n            industry VARCHAR(255),\n            notes TEXT,\n            created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n            updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n            is_active BOOLEAN DEFAULT true\n          );\n        `\n      });\n      if (clientsError) {\n        console.warn('Could not create clients table via RPC:', clientsError);\n      }\n    } catch (error) {\n      console.warn('Could not create tables automatically:', error);\n    }\n  }\n  async getClients() {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('clients').select('*').eq('is_active', true).order('name');\n      if (error) {\n        console.error('Error fetching clients:', error);\n        // If table doesn't exist, return empty array\n        if (error.code === '42P01') {\n          console.warn('Clients table does not exist, returning empty array');\n          return [];\n        }\n        throw error;\n      }\n      return data || [];\n    } catch (error) {\n      var _error$message, _error$message2;\n      console.error('Error fetching clients:', error);\n      // Return empty array for now if tables don't exist\n      if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('relation') && (_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('does not exist')) {\n        console.warn('Database tables not yet created, returning empty array');\n        return [];\n      }\n      throw error;\n    }\n  }\n  async getClient(clientId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('clients').select('*').eq('id', clientId).single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error fetching client:', error);\n      throw error;\n    }\n  }\n  async updateClient(clientId, updates) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('clients').update({\n        ...updates,\n        updated_at: new Date().toISOString()\n      }).eq('id', clientId).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error updating client:', error);\n      throw error;\n    }\n  }\n\n  // Project Management\n  async createClientProject(projectData) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('client_projects').insert([projectData]).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error creating client project:', error);\n      throw error;\n    }\n  }\n  async getClientProjects(clientId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('client_projects').select('*').eq('client_id', clientId).order('created_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error fetching client projects:', error);\n      throw error;\n    }\n  }\n\n  // Content Management\n  async createProjectContent(contentData) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('project_contents').insert([{\n        ...contentData,\n        stage: 'research',\n        stage_data: {}\n      }]).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error creating project content:', error);\n      throw error;\n    }\n  }\n  async getProjectContents(clientProjectId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('project_contents').select('*').eq('client_project_id', clientProjectId).order('created_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error fetching project contents:', error);\n      throw error;\n    }\n  }\n  async getProjectContent(contentId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('project_contents').select('*').eq('id', contentId).single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error fetching project content:', error);\n      throw error;\n    }\n  }\n\n  // Auto-save functionality\n  async autoSaveContent(contentId, stage, data) {\n    try {\n      // Update the main content record\n      const {\n        error: updateError\n      } = await supabase.from('project_contents').update({\n        stage,\n        stage_data: data,\n        last_saved_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      }).eq('id', contentId);\n      if (updateError) throw updateError;\n\n      // Save to auto_saves table for history\n      const {\n        error: saveError\n      } = await supabase.from('auto_saves').insert([{\n        content_id: contentId,\n        stage,\n        data\n      }]);\n      if (saveError) throw saveError;\n    } catch (error) {\n      console.error('Error auto-saving content:', error);\n      throw error;\n    }\n  }\n\n  // Dashboard data\n  async getClientDashboardData() {\n    try {\n      const {\n        data: clients,\n        error: clientError\n      } = await supabase.from('clients').select(`\n          *,\n          client_projects (\n            *,\n            project_contents (*)\n          )\n        `).eq('is_active', true).order('name');\n      if (clientError) throw clientError;\n\n      // Transform the data to match our TypeScript types\n      return (clients || []).map(client => ({\n        ...client,\n        projects: client.client_projects.map(project => ({\n          ...project,\n          contents: project.project_contents || []\n        }))\n      }));\n    } catch (error) {\n      console.error('Error fetching dashboard data:', error);\n      throw error;\n    }\n  }\n\n  // Search functionality\n  async searchContent(searchTerm) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('project_contents').select(`\n          *,\n          client_projects!inner (\n            *,\n            clients!inner (*)\n          )\n        `).or(`keyword.ilike.%${searchTerm}%,content_name.ilike.%${searchTerm}%`).order('updated_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error searching content:', error);\n      throw error;\n    }\n  }\n}\nexport const clientService = new ClientService();","map":{"version":3,"names":["supabase","ClientService","createClient","clientData","console","log","error","tableCheckError","from","select","limit","createTablesIfNotExist","data","insert","single","message","details","hint","code","Error","clientsError","rpc","sql","warn","getClients","eq","order","_error$message","_error$message2","includes","getClient","clientId","updateClient","updates","update","updated_at","Date","toISOString","createClientProject","projectData","getClientProjects","ascending","createProjectContent","contentData","stage","stage_data","getProjectContents","clientProjectId","getProjectContent","contentId","autoSaveContent","updateError","last_saved_at","saveError","content_id","getClientDashboardData","clients","clientError","map","client","projects","client_projects","project","contents","project_contents","searchContent","searchTerm","or","clientService"],"sources":["/Users/will/Content Creation App/src/services/client.service.ts"],"sourcesContent":["import { supabase } from './supabase.service';\nimport { Client, ClientProject, ProjectContent, ClientWithProjects } from '../types/client.types';\nimport { ProjectStage } from '../types/project.types';\n\nexport class ClientService {\n  // Client Management\n  async createClient(clientData: Omit<Client, 'id' | 'created_at' | 'updated_at'>): Promise<Client | null> {\n    try {\n      console.log('Attempting to create client:', clientData);\n      \n      // First, check if the clients table exists by trying to read from it\n      const { error: tableCheckError } = await supabase\n        .from('clients')\n        .select('id')\n        .limit(1);\n\n      if (tableCheckError) {\n        console.error('Clients table does not exist or is not accessible:', tableCheckError);\n        \n        // Try to create the table if it doesn't exist\n        await this.createTablesIfNotExist();\n      }\n\n      const { data, error } = await supabase\n        .from('clients')\n        .insert([clientData])\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Supabase insert error:', error);\n        throw error;\n      }\n      \n      console.log('Client created successfully:', data);\n      return data;\n    } catch (error: any) {\n      console.error('Error creating client:', error);\n      console.error('Error details:', {\n        message: error.message,\n        details: error.details,\n        hint: error.hint,\n        code: error.code\n      });\n      throw new Error(`Failed to create client: ${error.message}`);\n    }\n  }\n\n  // Helper method to create tables if they don't exist\n  private async createTablesIfNotExist(): Promise<void> {\n    try {\n      console.log('Attempting to create tables...');\n      \n      // Create clients table\n      const { error: clientsError } = await supabase.rpc('exec_sql', {\n        sql: `\n          CREATE TABLE IF NOT EXISTS clients (\n            id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            email VARCHAR(255),\n            company VARCHAR(255),\n            industry VARCHAR(255),\n            notes TEXT,\n            created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n            updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\n            is_active BOOLEAN DEFAULT true\n          );\n        `\n      });\n\n      if (clientsError) {\n        console.warn('Could not create clients table via RPC:', clientsError);\n      }\n\n    } catch (error) {\n      console.warn('Could not create tables automatically:', error);\n    }\n  }\n\n  async getClients(): Promise<Client[]> {\n    try {\n      const { data, error } = await supabase\n        .from('clients')\n        .select('*')\n        .eq('is_active', true)\n        .order('name');\n\n      if (error) {\n        console.error('Error fetching clients:', error);\n        // If table doesn't exist, return empty array\n        if (error.code === '42P01') {\n          console.warn('Clients table does not exist, returning empty array');\n          return [];\n        }\n        throw error;\n      }\n      return data || [];\n    } catch (error: any) {\n      console.error('Error fetching clients:', error);\n      // Return empty array for now if tables don't exist\n      if (error.message?.includes('relation') && error.message?.includes('does not exist')) {\n        console.warn('Database tables not yet created, returning empty array');\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  async getClient(clientId: string): Promise<Client | null> {\n    try {\n      const { data, error } = await supabase\n        .from('clients')\n        .select('*')\n        .eq('id', clientId)\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error fetching client:', error);\n      throw error;\n    }\n  }\n\n  async updateClient(clientId: string, updates: Partial<Client>): Promise<Client | null> {\n    try {\n      const { data, error } = await supabase\n        .from('clients')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', clientId)\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error updating client:', error);\n      throw error;\n    }\n  }\n\n  // Project Management\n  async createClientProject(projectData: Omit<ClientProject, 'id' | 'created_at' | 'updated_at'>): Promise<ClientProject | null> {\n    try {\n      const { data, error } = await supabase\n        .from('client_projects')\n        .insert([projectData])\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error creating client project:', error);\n      throw error;\n    }\n  }\n\n  async getClientProjects(clientId: string): Promise<ClientProject[]> {\n    try {\n      const { data, error } = await supabase\n        .from('client_projects')\n        .select('*')\n        .eq('client_id', clientId)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error fetching client projects:', error);\n      throw error;\n    }\n  }\n\n  // Content Management\n  async createProjectContent(contentData: {\n    client_project_id: string;\n    content_name: string;\n    keyword: string;\n  }): Promise<ProjectContent | null> {\n    try {\n      const { data, error } = await supabase\n        .from('project_contents')\n        .insert([{\n          ...contentData,\n          stage: 'research',\n          stage_data: {}\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error creating project content:', error);\n      throw error;\n    }\n  }\n\n  async getProjectContents(clientProjectId: string): Promise<ProjectContent[]> {\n    try {\n      const { data, error } = await supabase\n        .from('project_contents')\n        .select('*')\n        .eq('client_project_id', clientProjectId)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error fetching project contents:', error);\n      throw error;\n    }\n  }\n\n  async getProjectContent(contentId: string): Promise<ProjectContent | null> {\n    try {\n      const { data, error } = await supabase\n        .from('project_contents')\n        .select('*')\n        .eq('id', contentId)\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error fetching project content:', error);\n      throw error;\n    }\n  }\n\n  // Auto-save functionality\n  async autoSaveContent(contentId: string, stage: ProjectStage, data: any): Promise<void> {\n    try {\n      // Update the main content record\n      const { error: updateError } = await supabase\n        .from('project_contents')\n        .update({\n          stage,\n          stage_data: data,\n          last_saved_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', contentId);\n\n      if (updateError) throw updateError;\n\n      // Save to auto_saves table for history\n      const { error: saveError } = await supabase\n        .from('auto_saves')\n        .insert([{\n          content_id: contentId,\n          stage,\n          data\n        }]);\n\n      if (saveError) throw saveError;\n    } catch (error) {\n      console.error('Error auto-saving content:', error);\n      throw error;\n    }\n  }\n\n  // Dashboard data\n  async getClientDashboardData(): Promise<ClientWithProjects[]> {\n    try {\n      const { data: clients, error: clientError } = await supabase\n        .from('clients')\n        .select(`\n          *,\n          client_projects (\n            *,\n            project_contents (*)\n          )\n        `)\n        .eq('is_active', true)\n        .order('name');\n\n      if (clientError) throw clientError;\n\n      // Transform the data to match our TypeScript types\n      return (clients || []).map(client => ({\n        ...client,\n        projects: client.client_projects.map((project: any) => ({\n          ...project,\n          contents: project.project_contents || []\n        }))\n      }));\n    } catch (error) {\n      console.error('Error fetching dashboard data:', error);\n      throw error;\n    }\n  }\n\n  // Search functionality\n  async searchContent(searchTerm: string): Promise<ProjectContent[]> {\n    try {\n      const { data, error } = await supabase\n        .from('project_contents')\n        .select(`\n          *,\n          client_projects!inner (\n            *,\n            clients!inner (*)\n          )\n        `)\n        .or(`keyword.ilike.%${searchTerm}%,content_name.ilike.%${searchTerm}%`)\n        .order('updated_at', { ascending: false });\n\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error searching content:', error);\n      throw error;\n    }\n  }\n}\n\nexport const clientService = new ClientService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}