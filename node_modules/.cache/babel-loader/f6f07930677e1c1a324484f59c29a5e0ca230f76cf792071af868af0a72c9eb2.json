{"ast":null,"code":"// services/ai/backend-tts.service.ts\nimport axios from 'axios';\nconst BACKEND_TTS_URL = 'http://localhost:3001';\nexport class BackendTTSService {\n  async testBackendConnection() {\n    try {\n      const response = await axios.get(`${BACKEND_TTS_URL}/health`, {\n        timeout: 5000\n      });\n      console.log('‚úÖ Backend health check:', response.data);\n      return response.status === 200;\n    } catch (error) {\n      console.error('‚ùå Backend connection failed:', error);\n      return false;\n    }\n  }\n  async synthesizeSpeech(text, voice) {\n    console.log('üé§ Synthesizing speech via backend...');\n    console.log('Text length:', text.length);\n    console.log('Voice:', voice);\n    try {\n      const response = await axios.post(`${BACKEND_TTS_URL}/synthesize`, {\n        text,\n        voice\n      }, {\n        responseType: 'arraybuffer',\n        timeout: 30000,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.data) {\n        throw new Error('No audio data received from backend');\n      }\n\n      // Convert array buffer to blob URL\n      const audioBlob = new Blob([response.data], {\n        type: 'audio/mpeg'\n      });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      console.log('‚úÖ Audio synthesized successfully via backend');\n      return audioUrl;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3, _error$response3$data;\n      console.error('‚ùå Backend TTS synthesis failed:', error);\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('TTS backend server is not running. Please start the backend server first.');\n      }\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 403) {\n        throw new Error('TTS backend authentication failed. Check service account permissions.');\n      }\n      if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) {\n        throw new Error('TTS quota exceeded. Please try again later.');\n      }\n      throw new Error(`Backend TTS failed: ${((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.error) || error.message}`);\n    }\n  }\n  async synthesizePodcast(script) {\n    console.log('üéôÔ∏è  Synthesizing podcast via backend...');\n    try {\n      const response = await axios.post(`${BACKEND_TTS_URL}/synthesize-podcast`, {\n        script,\n        speakers: {\n          alex: 'en-US-Standard-J',\n          // Professional male voice\n          jordan: 'en-US-Standard-I' // Casual male voice\n        }\n      }, {\n        responseType: 'arraybuffer',\n        timeout: 60000,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.data) {\n        throw new Error('No audio data received from backend');\n      }\n\n      // Convert array buffer to blob URL\n      const audioBlob = new Blob([response.data], {\n        type: 'audio/mpeg'\n      });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      console.log('‚úÖ Podcast audio synthesized successfully');\n      console.log('Speaker:', response.headers['x-speaker']);\n      console.log('Voice:', response.headers['x-voice']);\n      return audioUrl;\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      console.error('‚ùå Backend podcast synthesis failed:', error);\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('TTS backend server is not running. Please start the backend server first.');\n      }\n      throw new Error(`Podcast synthesis failed: ${((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.error) || error.message}`);\n    }\n  }\n  parseScriptForVoices(script) {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments = [];\n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({\n          speaker,\n          text: text.trim()\n        });\n      }\n    }\n    return segments;\n  }\n  async generateAudio(podcastScript) {\n    var _podcastScript$script;\n    console.log('=== BACKEND TTS AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', ((_podcastScript$script = podcastScript.script) === null || _podcastScript$script === void 0 ? void 0 : _podcastScript$script.length) || 0);\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Check if backend is running\n    const isBackendRunning = await this.testBackendConnection();\n    if (!isBackendRunning) {\n      throw new Error('TTS backend server is not running. Please start the backend server by running \"npm start\" in the tts-backend folder.');\n    }\n\n    // Try podcast synthesis first (handles multiple speakers)\n    try {\n      console.log('üéØ Attempting podcast synthesis...');\n      const audioUrl = await this.synthesizePodcast(podcastScript.script);\n\n      // Parse segments to get info for metadata\n      const segments = this.parseScriptForVoices(podcastScript.script);\n      const firstSegment = segments.length > 0 ? segments[0] : null;\n      return {\n        audioUrl,\n        duration: Math.ceil(((firstSegment === null || firstSegment === void 0 ? void 0 : firstSegment.text.length) || 1000) / 150),\n        // Rough estimate\n        format: 'mp3',\n        size: Math.ceil(((firstSegment === null || firstSegment === void 0 ? void 0 : firstSegment.text.length) || 1000) / 10),\n        // Rough estimate\n        transcript: (firstSegment === null || firstSegment === void 0 ? void 0 : firstSegment.text) || podcastScript.script.substring(0, 2000)\n      };\n    } catch (podcastError) {\n      console.warn('Podcast synthesis failed, trying single voice fallback...');\n\n      // Fallback: use single voice for entire script\n      const limitedScript = podcastScript.script.substring(0, 2000);\n      const audioUrl = await this.synthesizeSpeech(limitedScript, 'en-US-Standard-J');\n      return {\n        audioUrl,\n        duration: Math.ceil(limitedScript.length / 150),\n        format: 'mp3',\n        size: Math.ceil(limitedScript.length / 10),\n        transcript: limitedScript\n      };\n    }\n  }\n}\nexport const backendTTSService = new BackendTTSService();","map":{"version":3,"names":["axios","BACKEND_TTS_URL","BackendTTSService","testBackendConnection","response","get","timeout","console","log","data","status","error","synthesizeSpeech","text","voice","length","post","responseType","headers","Error","audioBlob","Blob","type","audioUrl","URL","createObjectURL","_error$response","_error$response2","_error$response3","_error$response3$data","code","message","synthesizePodcast","script","speakers","alex","jordan","_error$response4","_error$response4$data","parseScriptForVoices","lines","split","filter","line","trim","segments","match","speaker","push","generateAudio","podcastScript","_podcastScript$script","title","isBackendRunning","firstSegment","duration","Math","ceil","format","size","transcript","substring","podcastError","warn","limitedScript","backendTTSService"],"sources":["/Users/will/Content Creation App/src/services/ai/backend-tts.service.ts"],"sourcesContent":["// services/ai/backend-tts.service.ts\nimport axios from 'axios';\nimport { PodcastContent, AudioContent } from '../../types/project.types';\n\nconst BACKEND_TTS_URL = 'http://localhost:3001';\n\nexport class BackendTTSService {\n  private async testBackendConnection(): Promise<boolean> {\n    try {\n      const response = await axios.get(`${BACKEND_TTS_URL}/health`, { timeout: 5000 });\n      console.log('‚úÖ Backend health check:', response.data);\n      return response.status === 200;\n    } catch (error) {\n      console.error('‚ùå Backend connection failed:', error);\n      return false;\n    }\n  }\n\n  private async synthesizeSpeech(text: string, voice: string): Promise<string> {\n    console.log('üé§ Synthesizing speech via backend...');\n    console.log('Text length:', text.length);\n    console.log('Voice:', voice);\n\n    try {\n      const response = await axios.post(\n        `${BACKEND_TTS_URL}/synthesize`,\n        { text, voice },\n        {\n          responseType: 'arraybuffer',\n          timeout: 30000,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n\n      if (!response.data) {\n        throw new Error('No audio data received from backend');\n      }\n\n      // Convert array buffer to blob URL\n      const audioBlob = new Blob([response.data], { type: 'audio/mpeg' });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      \n      console.log('‚úÖ Audio synthesized successfully via backend');\n      return audioUrl;\n    } catch (error: any) {\n      console.error('‚ùå Backend TTS synthesis failed:', error);\n      \n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('TTS backend server is not running. Please start the backend server first.');\n      }\n      \n      if (error.response?.status === 403) {\n        throw new Error('TTS backend authentication failed. Check service account permissions.');\n      }\n      \n      if (error.response?.status === 429) {\n        throw new Error('TTS quota exceeded. Please try again later.');\n      }\n      \n      throw new Error(`Backend TTS failed: ${error.response?.data?.error || error.message}`);\n    }\n  }\n\n  private async synthesizePodcast(script: string): Promise<string> {\n    console.log('üéôÔ∏è  Synthesizing podcast via backend...');\n\n    try {\n      const response = await axios.post(\n        `${BACKEND_TTS_URL}/synthesize-podcast`,\n        { \n          script,\n          speakers: {\n            alex: 'en-US-Standard-J', // Professional male voice\n            jordan: 'en-US-Standard-I' // Casual male voice\n          }\n        },\n        {\n          responseType: 'arraybuffer',\n          timeout: 60000,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n\n      if (!response.data) {\n        throw new Error('No audio data received from backend');\n      }\n\n      // Convert array buffer to blob URL\n      const audioBlob = new Blob([response.data], { type: 'audio/mpeg' });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      \n      console.log('‚úÖ Podcast audio synthesized successfully');\n      console.log('Speaker:', response.headers['x-speaker']);\n      console.log('Voice:', response.headers['x-voice']);\n      \n      return audioUrl;\n    } catch (error: any) {\n      console.error('‚ùå Backend podcast synthesis failed:', error);\n      \n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('TTS backend server is not running. Please start the backend server first.');\n      }\n      \n      throw new Error(`Podcast synthesis failed: ${error.response?.data?.error || error.message}`);\n    }\n  }\n\n  private parseScriptForVoices(script: string): Array<{speaker: string, text: string}> {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments: Array<{speaker: string, text: string}> = [];\n    \n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({ speaker, text: text.trim() });\n      }\n    }\n    \n    return segments;\n  }\n\n  async generateAudio(podcastScript: PodcastContent): Promise<AudioContent> {\n    console.log('=== BACKEND TTS AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', podcastScript.script?.length || 0);\n\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Check if backend is running\n    const isBackendRunning = await this.testBackendConnection();\n    if (!isBackendRunning) {\n      throw new Error('TTS backend server is not running. Please start the backend server by running \"npm start\" in the tts-backend folder.');\n    }\n\n    // Try podcast synthesis first (handles multiple speakers)\n    try {\n      console.log('üéØ Attempting podcast synthesis...');\n      const audioUrl = await this.synthesizePodcast(podcastScript.script);\n      \n      // Parse segments to get info for metadata\n      const segments = this.parseScriptForVoices(podcastScript.script);\n      const firstSegment = segments.length > 0 ? segments[0] : null;\n      \n      return {\n        audioUrl,\n        duration: Math.ceil((firstSegment?.text.length || 1000) / 150), // Rough estimate\n        format: 'mp3',\n        size: Math.ceil((firstSegment?.text.length || 1000) / 10), // Rough estimate\n        transcript: firstSegment?.text || podcastScript.script.substring(0, 2000)\n      };\n    } catch (podcastError) {\n      console.warn('Podcast synthesis failed, trying single voice fallback...');\n      \n      // Fallback: use single voice for entire script\n      const limitedScript = podcastScript.script.substring(0, 2000);\n      const audioUrl = await this.synthesizeSpeech(limitedScript, 'en-US-Standard-J');\n      \n      return {\n        audioUrl,\n        duration: Math.ceil(limitedScript.length / 150),\n        format: 'mp3',\n        size: Math.ceil(limitedScript.length / 10),\n        transcript: limitedScript\n      };\n    }\n  }\n}\n\nexport const backendTTSService = new BackendTTSService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}