{"ast":null,"code":"// services/ai/gemini.service.ts\nimport axios from 'axios';\nconst GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nconst GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-06-05:generateContent';\nconst GOOGLE_TTS_API_URL = 'https://texttospeech.googleapis.com/v1/text:synthesize';\nexport class GeminiService {\n  async makeRequest(prompt) {\n    console.log('=== GEMINI API REQUEST ===');\n    console.log('API Key exists:', !!GEMINI_API_KEY);\n    console.log('API Key length:', (GEMINI_API_KEY === null || GEMINI_API_KEY === void 0 ? void 0 : GEMINI_API_KEY.length) || 0);\n    console.log('API Key preview:', (GEMINI_API_KEY === null || GEMINI_API_KEY === void 0 ? void 0 : GEMINI_API_KEY.substring(0, 10)) + '...' || 'None');\n    console.log('API URL:', GEMINI_API_URL);\n    console.log('Prompt length:', prompt.length);\n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    try {\n      console.time('Gemini API Call');\n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 4096\n        }\n      };\n      console.log('Request body prepared for Gemini API');\n      const response = await axios.post(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, requestBody, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        timeout: 120000 // 2 minute timeout\n      });\n      console.timeEnd('Gemini API Call');\n      console.log('API response status:', response.status);\n      console.log('API response data keys:', Object.keys(response.data || {}));\n      console.log('Full API response data:', JSON.stringify(response.data, null, 2));\n      if (!response.data) {\n        console.error('Response data is null/undefined');\n        throw new Error('No data in API response');\n      }\n      if (!response.data.candidates || !Array.isArray(response.data.candidates)) {\n        console.error('Missing candidates field in response');\n        console.log('Available fields:', Object.keys(response.data));\n        throw new Error('No candidates field in API response');\n      }\n      if (response.data.candidates.length === 0) {\n        console.error('Candidates array is empty');\n        throw new Error('No candidates in API response');\n      }\n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || !Array.isArray(candidate.content.parts)) {\n        console.error('Invalid candidate structure');\n        console.log('Candidate structure:', JSON.stringify(candidate, null, 2));\n        throw new Error('Invalid candidate content structure');\n      }\n      if (candidate.content.parts.length === 0 || !candidate.content.parts[0].text) {\n        console.error('No text content in candidate');\n        throw new Error('No text content in API response');\n      }\n      const textContent = candidate.content.parts[0].text;\n      console.log('Successfully extracted text, length:', textContent.length);\n      console.log('Text preview:', textContent.substring(0, 200) + '...');\n      return textContent;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3, _error$response4, _error$response5, _error$response6, _error$response7, _error$response9, _error$response9$data, _error$response9$data2;\n      console.error('=== GEMINI API ERROR ===');\n      console.error('Error type:', error.constructor.name);\n      console.error('Error message:', error.message);\n      console.error('Error code:', error.code);\n      console.error('Error status:', (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status);\n      console.error('Error status text:', (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.statusText);\n      console.error('Error response headers:', (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.headers);\n      console.error('Error response data:', JSON.stringify((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data, null, 2));\n      console.error('Is network error:', error.message.includes('Network Error'));\n      console.error('Is timeout:', error.code === 'ECONNABORTED');\n      console.error('Full error stack:', error.stack);\n      console.error('===========================');\n      if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out - please try again');\n      }\n      if (error.message.includes('Network Error')) {\n        throw new Error('Network error connecting to Gemini API. Please check your internet connection.');\n      }\n      if (((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) === 401) {\n        throw new Error('Invalid API key. Please check your Gemini API key configuration.');\n      }\n      if (((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) === 429) {\n        throw new Error('Rate limit exceeded. Please wait a moment and try again.');\n      }\n      if (((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.status) === 400) {\n        var _error$response8, _error$response8$data, _error$response8$data2;\n        throw new Error(`Bad request: ${((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : (_error$response8$data = _error$response8.data) === null || _error$response8$data === void 0 ? void 0 : (_error$response8$data2 = _error$response8$data.error) === null || _error$response8$data2 === void 0 ? void 0 : _error$response8$data2.message) || 'Invalid request format'}`);\n      }\n      const errorMessage = ((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : (_error$response9$data = _error$response9.data) === null || _error$response9$data === void 0 ? void 0 : (_error$response9$data2 = _error$response9$data.error) === null || _error$response9$data2 === void 0 ? void 0 : _error$response9$data2.message) || error.message || 'Failed to generate content';\n      throw new Error(errorMessage);\n    }\n  }\n  async synthesizeSpeech(text, voiceName) {\n    console.log('=== GOOGLE TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Voice:', voiceName);\n    try {\n      const requestBody = {\n        input: {\n          text\n        },\n        voice: {\n          languageCode: 'en-US',\n          name: voiceName,\n          ssmlGender: voiceName.includes('Standard-A') || voiceName.includes('Standard-C') ? 'FEMALE' : 'MALE'\n        },\n        audioConfig: {\n          audioEncoding: 'MP3',\n          speakingRate: 1.0,\n          pitch: 0.0,\n          volumeGainDb: 0.0\n        }\n      };\n      const response = await axios.post(`${GOOGLE_TTS_API_URL}?key=${GEMINI_API_KEY}`, requestBody, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        timeout: 60000\n      });\n      if (!response.data.audioContent) {\n        throw new Error('No audio content in TTS response');\n      }\n\n      // Convert base64 audio to blob URL\n      const audioBytes = response.data.audioContent;\n      const audioBlob = new Blob([Uint8Array.from(atob(audioBytes), c => c.charCodeAt(0))], {\n        type: 'audio/mp3'\n      });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      console.log('TTS synthesis successful, audio URL created');\n      return audioUrl;\n    } catch (error) {\n      console.error('TTS synthesis failed:', error);\n      throw new Error(`TTS failed: ${error.message}`);\n    }\n  }\n  parseScriptForVoices(script) {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments = [];\n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({\n          speaker,\n          text: text.trim()\n        });\n      }\n    }\n    return segments;\n  }\n  async generateAudio(podcastScript) {\n    var _podcastScript$script;\n    console.log('Generating REAL audio for podcast:', podcastScript.title);\n    console.log('Script length:', ((_podcastScript$script = podcastScript.script) === null || _podcastScript$script === void 0 ? void 0 : _podcastScript$script.length) || 0);\n    try {\n      // Parse the script to extract speaker segments\n      const segments = this.parseScriptForVoices(podcastScript.script);\n      console.log('Found segments:', segments.length);\n      if (segments.length === 0) {\n        // Fallback: treat entire script as single voice\n        console.log('No speaker segments found, using single voice');\n        const audioUrl = await this.synthesizeSpeech(podcastScript.script, 'en-US-Standard-J');\n        return {\n          audioUrl,\n          duration: podcastScript.duration * 60,\n          format: 'mp3',\n          size: podcastScript.duration * 1.5 * 1024 * 1024,\n          // Estimate\n          transcript: podcastScript.script\n        };\n      }\n\n      // Generate audio for each segment with appropriate voices\n      console.log('Generating multi-voice audio...');\n      const audioSegments = [];\n      for (const segment of segments.slice(0, 5)) {\n        // Limit to first 5 segments for testing\n        const voiceName = segment.speaker === 'Alex' ? 'en-US-Standard-J' : 'en-US-Standard-I'; // Male voices\n        console.log(`Generating audio for ${segment.speaker}: ${segment.text.substring(0, 50)}...`);\n        try {\n          const segmentAudioUrl = await this.synthesizeSpeech(segment.text, voiceName);\n          audioSegments.push(segmentAudioUrl);\n        } catch (segmentError) {\n          console.warn(`Failed to generate audio for segment: ${segmentError}`);\n          // Continue with other segments\n        }\n      }\n      if (audioSegments.length === 0) {\n        throw new Error('Failed to generate any audio segments');\n      }\n\n      // For now, return the first segment (in production, you'd combine them)\n      const finalAudioUrl = audioSegments[0];\n      return {\n        audioUrl: finalAudioUrl,\n        duration: Math.min(podcastScript.duration * 60, 300),\n        // Cap at 5 minutes for testing\n        format: 'mp3',\n        size: audioSegments.length * 1.5 * 1024 * 1024,\n        // Estimate based on segments\n        transcript: podcastScript.script\n      };\n    } catch (error) {\n      console.error('Real audio generation failed, falling back to simulation:', error);\n\n      // Fallback to simulation if TTS fails\n      const prompt = `Based on the following podcast script, generate detailed audio production instructions and metadata for creating high-quality audio content.\n\nPODCAST SCRIPT:\n${podcastScript.script}\n\nPODCAST DETAILS:\n- Title: ${podcastScript.title}\n- Duration: ${podcastScript.duration} minutes\n- Hosts: Alex (analytical voice) and Jordan (casual voice)\n\nGenerate detailed instructions for:\n1. Voice characteristics for each host\n2. Pacing and timing guidelines\n3. Sound effects and music cues\n4. Audio production notes\n5. Quality specifications\n\nAlso generate a simulated audio file metadata response.\n\nFORMAT YOUR RESPONSE AS JSON:\n{\n  \"audioInstructions\": {\n    \"alexVoice\": \"Detailed voice characteristics for Alex\",\n    \"jordanVoice\": \"Detailed voice characteristics for Jordan\", \n    \"pacing\": \"Pacing and timing guidelines\",\n    \"soundEffects\": [\"effect1\", \"effect2\"],\n    \"musicCues\": [\"intro music\", \"transition music\", \"outro music\"],\n    \"productionNotes\": \"Detailed production guidelines\"\n  },\n  \"audioMetadata\": {\n    \"duration\": ${podcastScript.duration * 60},\n    \"format\": \"mp3\",\n    \"bitrate\": \"192kbps\",\n    \"sampleRate\": \"44.1kHz\",\n    \"estimatedSize\": \"${Math.round(podcastScript.duration * 1.5)}MB\"\n  },\n  \"transcript\": \"Clean transcript version of the podcast script without speaker names\",\n  \"audioUrl\": \"https://example.com/generated-audio.mp3\"\n}\n\nGenerate comprehensive audio production guidance for this podcast episode.`;\n      try {\n        const response = await this.makeRequest(prompt);\n        console.log('=== AUDIO GENERATION RESPONSE DEBUG ===');\n        console.log('Raw response length:', (response === null || response === void 0 ? void 0 : response.length) || 0);\n        console.log('Response preview:', (response === null || response === void 0 ? void 0 : response.substring(0, 300)) || 'No response');\n        console.log('==============================');\n        if (!response || response.length === 0) {\n          throw new Error('Empty response from Gemini API');\n        }\n\n        // Try to parse the response\n        try {\n          var _audioData$audioMetad, _audioData$audioMetad2, _audioData$audioMetad3, _audioData$audioMetad4;\n          const audioData = JSON.parse(response);\n          console.log('Parsed audio data keys:', Object.keys(audioData || {}));\n\n          // Create final audio content structure\n          const audioContent = {\n            audioUrl: audioData.audioUrl || `https://example.com/podcast-${Date.now()}.mp3`,\n            duration: ((_audioData$audioMetad = audioData.audioMetadata) === null || _audioData$audioMetad === void 0 ? void 0 : _audioData$audioMetad.duration) || podcastScript.duration * 60,\n            format: ((_audioData$audioMetad2 = audioData.audioMetadata) === null || _audioData$audioMetad2 === void 0 ? void 0 : _audioData$audioMetad2.format) || 'mp3',\n            size: parseInt(((_audioData$audioMetad3 = audioData.audioMetadata) === null || _audioData$audioMetad3 === void 0 ? void 0 : (_audioData$audioMetad4 = _audioData$audioMetad3.estimatedSize) === null || _audioData$audioMetad4 === void 0 ? void 0 : _audioData$audioMetad4.replace('MB', '')) || '15') * 1024 * 1024,\n            transcript: audioData.transcript || podcastScript.script || ''\n          };\n          console.log('Final audio content structure:', {\n            hasAudioUrl: !!audioContent.audioUrl,\n            duration: audioContent.duration,\n            format: audioContent.format,\n            sizeInMB: Math.round(audioContent.size / (1024 * 1024))\n          });\n          return audioContent;\n        } catch (parseError) {\n          console.error('Failed to parse audio JSON response:', parseError);\n          console.log('Attempting to create fallback audio content...');\n\n          // Fallback: create basic audio content structure\n          console.log('Using fallback audio structure');\n          return {\n            audioUrl: `https://example.com/podcast-${Date.now()}.mp3`,\n            duration: podcastScript.duration * 60,\n            format: 'mp3',\n            size: podcastScript.duration * 1.5 * 1024 * 1024,\n            // Estimate 1.5MB per minute\n            transcript: podcastScript.script || ''\n          };\n        }\n      } catch (error) {\n        console.error('=== AUDIO GENERATION ERROR ===');\n        console.error('Error type:', error.constructor.name);\n        console.error('Error message:', error.message);\n        console.error('Error stack:', error.stack);\n        console.error('================================');\n        throw error;\n      }\n    }\n  }\n}\nexport const geminiService = new GeminiService();","map":{"version":3,"names":["axios","GEMINI_API_KEY","process","env","REACT_APP_GEMINI_API_KEY","GEMINI_API_URL","GOOGLE_TTS_API_URL","GeminiService","makeRequest","prompt","console","log","length","substring","Error","time","requestBody","contents","parts","text","generationConfig","temperature","topK","topP","maxOutputTokens","response","post","headers","timeout","timeEnd","status","Object","keys","data","JSON","stringify","error","candidates","Array","isArray","candidate","content","textContent","_error$response","_error$response2","_error$response3","_error$response4","_error$response5","_error$response6","_error$response7","_error$response9","_error$response9$data","_error$response9$data2","constructor","name","message","code","statusText","includes","stack","_error$response8","_error$response8$data","_error$response8$data2","errorMessage","synthesizeSpeech","voiceName","input","voice","languageCode","ssmlGender","audioConfig","audioEncoding","speakingRate","pitch","volumeGainDb","audioContent","audioBytes","audioBlob","Blob","Uint8Array","from","atob","c","charCodeAt","type","audioUrl","URL","createObjectURL","parseScriptForVoices","script","lines","split","filter","line","trim","segments","match","speaker","push","generateAudio","podcastScript","_podcastScript$script","title","duration","format","size","transcript","audioSegments","segment","slice","segmentAudioUrl","segmentError","warn","finalAudioUrl","Math","min","round","_audioData$audioMetad","_audioData$audioMetad2","_audioData$audioMetad3","_audioData$audioMetad4","audioData","parse","Date","now","audioMetadata","parseInt","estimatedSize","replace","hasAudioUrl","sizeInMB","parseError","geminiService"],"sources":["/Users/will/Content Creation App/src/services/ai/gemini.service.ts"],"sourcesContent":["// services/ai/gemini.service.ts\nimport axios from 'axios';\nimport { PodcastContent } from '../../types/project.types';\n\nconst GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nconst GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-06-05:generateContent';\nconst GOOGLE_TTS_API_URL = 'https://texttospeech.googleapis.com/v1/text:synthesize';\n\nexport interface AudioContent {\n  audioUrl: string;\n  duration: number;\n  format: string;\n  size: number;\n  transcript: string;\n}\n\nexport class GeminiService {\n  private async makeRequest(prompt: string): Promise<string> {\n    console.log('=== GEMINI API REQUEST ===');\n    console.log('API Key exists:', !!GEMINI_API_KEY);\n    console.log('API Key length:', GEMINI_API_KEY?.length || 0);\n    console.log('API Key preview:', GEMINI_API_KEY?.substring(0, 10) + '...' || 'None');\n    console.log('API URL:', GEMINI_API_URL);\n    console.log('Prompt length:', prompt.length);\n    \n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    \n    try {\n      console.time('Gemini API Call');\n      \n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 4096,\n        }\n      };\n      \n      console.log('Request body prepared for Gemini API');\n      \n      const response = await axios.post(\n        `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,\n        requestBody,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          timeout: 120000, // 2 minute timeout\n        }\n      );\n\n      console.timeEnd('Gemini API Call');\n      console.log('API response status:', response.status);\n      console.log('API response data keys:', Object.keys(response.data || {}));\n      console.log('Full API response data:', JSON.stringify(response.data, null, 2));\n      \n      if (!response.data) {\n        console.error('Response data is null/undefined');\n        throw new Error('No data in API response');\n      }\n      \n      if (!response.data.candidates || !Array.isArray(response.data.candidates)) {\n        console.error('Missing candidates field in response');\n        console.log('Available fields:', Object.keys(response.data));\n        throw new Error('No candidates field in API response');\n      }\n      \n      if (response.data.candidates.length === 0) {\n        console.error('Candidates array is empty');\n        throw new Error('No candidates in API response');\n      }\n      \n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || !Array.isArray(candidate.content.parts)) {\n        console.error('Invalid candidate structure');\n        console.log('Candidate structure:', JSON.stringify(candidate, null, 2));\n        throw new Error('Invalid candidate content structure');\n      }\n      \n      if (candidate.content.parts.length === 0 || !candidate.content.parts[0].text) {\n        console.error('No text content in candidate');\n        throw new Error('No text content in API response');\n      }\n      \n      const textContent = candidate.content.parts[0].text;\n      console.log('Successfully extracted text, length:', textContent.length);\n      console.log('Text preview:', textContent.substring(0, 200) + '...');\n      return textContent;\n    } catch (error: any) {\n      console.error('=== GEMINI API ERROR ===');\n      console.error('Error type:', error.constructor.name);\n      console.error('Error message:', error.message);\n      console.error('Error code:', error.code);\n      console.error('Error status:', error.response?.status);\n      console.error('Error status text:', error.response?.statusText);\n      console.error('Error response headers:', error.response?.headers);\n      console.error('Error response data:', JSON.stringify(error.response?.data, null, 2));\n      console.error('Is network error:', error.message.includes('Network Error'));\n      console.error('Is timeout:', error.code === 'ECONNABORTED');\n      console.error('Full error stack:', error.stack);\n      console.error('===========================');\n      \n      if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out - please try again');\n      }\n      \n      if (error.message.includes('Network Error')) {\n        throw new Error('Network error connecting to Gemini API. Please check your internet connection.');\n      }\n      \n      if (error.response?.status === 401) {\n        throw new Error('Invalid API key. Please check your Gemini API key configuration.');\n      }\n      \n      if (error.response?.status === 429) {\n        throw new Error('Rate limit exceeded. Please wait a moment and try again.');\n      }\n      \n      if (error.response?.status === 400) {\n        throw new Error(`Bad request: ${error.response?.data?.error?.message || 'Invalid request format'}`);\n      }\n      \n      const errorMessage = error.response?.data?.error?.message || error.message || 'Failed to generate content';\n      throw new Error(errorMessage);\n    }\n  }\n\n  private async synthesizeSpeech(text: string, voiceName: string): Promise<string> {\n    console.log('=== GOOGLE TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Voice:', voiceName);\n    \n    try {\n      const requestBody = {\n        input: { text },\n        voice: {\n          languageCode: 'en-US',\n          name: voiceName,\n          ssmlGender: voiceName.includes('Standard-A') || voiceName.includes('Standard-C') ? 'FEMALE' : 'MALE'\n        },\n        audioConfig: {\n          audioEncoding: 'MP3',\n          speakingRate: 1.0,\n          pitch: 0.0,\n          volumeGainDb: 0.0\n        }\n      };\n\n      const response = await axios.post(\n        `${GOOGLE_TTS_API_URL}?key=${GEMINI_API_KEY}`,\n        requestBody,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          timeout: 60000,\n        }\n      );\n\n      if (!response.data.audioContent) {\n        throw new Error('No audio content in TTS response');\n      }\n\n      // Convert base64 audio to blob URL\n      const audioBytes = response.data.audioContent;\n      const audioBlob = new Blob([Uint8Array.from(atob(audioBytes), c => c.charCodeAt(0))], { type: 'audio/mp3' });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      \n      console.log('TTS synthesis successful, audio URL created');\n      return audioUrl;\n    } catch (error: any) {\n      console.error('TTS synthesis failed:', error);\n      throw new Error(`TTS failed: ${error.message}`);\n    }\n  }\n\n  private parseScriptForVoices(script: string): Array<{speaker: string, text: string}> {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments: Array<{speaker: string, text: string}> = [];\n    \n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({ speaker, text: text.trim() });\n      }\n    }\n    \n    return segments;\n  }\n\n  async generateAudio(podcastScript: PodcastContent): Promise<AudioContent> {\n    console.log('Generating REAL audio for podcast:', podcastScript.title);\n    console.log('Script length:', podcastScript.script?.length || 0);\n\n    try {\n      // Parse the script to extract speaker segments\n      const segments = this.parseScriptForVoices(podcastScript.script);\n      console.log('Found segments:', segments.length);\n\n      if (segments.length === 0) {\n        // Fallback: treat entire script as single voice\n        console.log('No speaker segments found, using single voice');\n        const audioUrl = await this.synthesizeSpeech(podcastScript.script, 'en-US-Standard-J');\n        \n        return {\n          audioUrl,\n          duration: podcastScript.duration * 60,\n          format: 'mp3',\n          size: podcastScript.duration * 1.5 * 1024 * 1024, // Estimate\n          transcript: podcastScript.script\n        };\n      }\n\n      // Generate audio for each segment with appropriate voices\n      console.log('Generating multi-voice audio...');\n      const audioSegments: string[] = [];\n      \n      for (const segment of segments.slice(0, 5)) { // Limit to first 5 segments for testing\n        const voiceName = segment.speaker === 'Alex' ? 'en-US-Standard-J' : 'en-US-Standard-I'; // Male voices\n        console.log(`Generating audio for ${segment.speaker}: ${segment.text.substring(0, 50)}...`);\n        \n        try {\n          const segmentAudioUrl = await this.synthesizeSpeech(segment.text, voiceName);\n          audioSegments.push(segmentAudioUrl);\n        } catch (segmentError) {\n          console.warn(`Failed to generate audio for segment: ${segmentError}`);\n          // Continue with other segments\n        }\n      }\n\n      if (audioSegments.length === 0) {\n        throw new Error('Failed to generate any audio segments');\n      }\n\n      // For now, return the first segment (in production, you'd combine them)\n      const finalAudioUrl = audioSegments[0];\n      \n      return {\n        audioUrl: finalAudioUrl,\n        duration: Math.min(podcastScript.duration * 60, 300), // Cap at 5 minutes for testing\n        format: 'mp3',\n        size: audioSegments.length * 1.5 * 1024 * 1024, // Estimate based on segments\n        transcript: podcastScript.script\n      };\n    } catch (error: any) {\n      console.error('Real audio generation failed, falling back to simulation:', error);\n      \n      // Fallback to simulation if TTS fails\n      const prompt = `Based on the following podcast script, generate detailed audio production instructions and metadata for creating high-quality audio content.\n\nPODCAST SCRIPT:\n${podcastScript.script}\n\nPODCAST DETAILS:\n- Title: ${podcastScript.title}\n- Duration: ${podcastScript.duration} minutes\n- Hosts: Alex (analytical voice) and Jordan (casual voice)\n\nGenerate detailed instructions for:\n1. Voice characteristics for each host\n2. Pacing and timing guidelines\n3. Sound effects and music cues\n4. Audio production notes\n5. Quality specifications\n\nAlso generate a simulated audio file metadata response.\n\nFORMAT YOUR RESPONSE AS JSON:\n{\n  \"audioInstructions\": {\n    \"alexVoice\": \"Detailed voice characteristics for Alex\",\n    \"jordanVoice\": \"Detailed voice characteristics for Jordan\", \n    \"pacing\": \"Pacing and timing guidelines\",\n    \"soundEffects\": [\"effect1\", \"effect2\"],\n    \"musicCues\": [\"intro music\", \"transition music\", \"outro music\"],\n    \"productionNotes\": \"Detailed production guidelines\"\n  },\n  \"audioMetadata\": {\n    \"duration\": ${podcastScript.duration * 60},\n    \"format\": \"mp3\",\n    \"bitrate\": \"192kbps\",\n    \"sampleRate\": \"44.1kHz\",\n    \"estimatedSize\": \"${Math.round(podcastScript.duration * 1.5)}MB\"\n  },\n  \"transcript\": \"Clean transcript version of the podcast script without speaker names\",\n  \"audioUrl\": \"https://example.com/generated-audio.mp3\"\n}\n\nGenerate comprehensive audio production guidance for this podcast episode.`;\n\n    try {\n      const response = await this.makeRequest(prompt);\n      \n      console.log('=== AUDIO GENERATION RESPONSE DEBUG ===');\n      console.log('Raw response length:', response?.length || 0);\n      console.log('Response preview:', response?.substring(0, 300) || 'No response');\n      console.log('==============================');\n      \n      if (!response || response.length === 0) {\n        throw new Error('Empty response from Gemini API');\n      }\n      \n      // Try to parse the response\n      try {\n        const audioData = JSON.parse(response);\n        \n        console.log('Parsed audio data keys:', Object.keys(audioData || {}));\n        \n        // Create final audio content structure\n        const audioContent: AudioContent = {\n          audioUrl: audioData.audioUrl || `https://example.com/podcast-${Date.now()}.mp3`,\n          duration: audioData.audioMetadata?.duration || podcastScript.duration * 60,\n          format: audioData.audioMetadata?.format || 'mp3',\n          size: parseInt(audioData.audioMetadata?.estimatedSize?.replace('MB', '') || '15') * 1024 * 1024,\n          transcript: audioData.transcript || podcastScript.script || ''\n        };\n        \n        console.log('Final audio content structure:', {\n          hasAudioUrl: !!audioContent.audioUrl,\n          duration: audioContent.duration,\n          format: audioContent.format,\n          sizeInMB: Math.round(audioContent.size / (1024 * 1024))\n        });\n        \n        return audioContent;\n      } catch (parseError) {\n        console.error('Failed to parse audio JSON response:', parseError);\n        console.log('Attempting to create fallback audio content...');\n        \n        // Fallback: create basic audio content structure\n        console.log('Using fallback audio structure');\n        return {\n          audioUrl: `https://example.com/podcast-${Date.now()}.mp3`,\n          duration: podcastScript.duration * 60,\n          format: 'mp3',\n          size: podcastScript.duration * 1.5 * 1024 * 1024, // Estimate 1.5MB per minute\n          transcript: podcastScript.script || ''\n        };\n      }\n    } catch (error: any) {\n      console.error('=== AUDIO GENERATION ERROR ===');\n      console.error('Error type:', error.constructor.name);\n      console.error('Error message:', error.message);\n      console.error('Error stack:', error.stack);\n      console.error('================================');\n      throw error;\n    }\n    }\n  }\n}\n\nexport const geminiService = new GeminiService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}