{"ast":null,"code":"// services/ai/gemini.service.ts\nimport axios from 'axios';\nimport { elevenLabsService } from './elevenlabs.service';\nimport { backendTTSService } from './backend-tts.service';\nconst GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nconst GEMINI_TTS_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';\nconst GEMINI_PRO_TTS_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-tts:generateContent';\nconst GOOGLE_TTS_API_URL = 'https://texttospeech.googleapis.com/v1/text:synthesize';\nexport class GeminiService {\n  async makeRequest(prompt) {\n    console.log('=== GEMINI API REQUEST ===');\n    console.log('API Key exists:', !!GEMINI_API_KEY);\n    console.log('API Key length:', (GEMINI_API_KEY === null || GEMINI_API_KEY === void 0 ? void 0 : GEMINI_API_KEY.length) || 0);\n    console.log('API Key preview:', (GEMINI_API_KEY === null || GEMINI_API_KEY === void 0 ? void 0 : GEMINI_API_KEY.substring(0, 10)) + '...' || 'None');\n    console.log('API URL:', GEMINI_TTS_API_URL);\n    console.log('Prompt length:', prompt.length);\n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    try {\n      console.time('Gemini API Call');\n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 4096\n        }\n      };\n      console.log('Request body prepared for Gemini API');\n      const response = await axios.post(`${GEMINI_TTS_API_URL}?key=${GEMINI_API_KEY}`, requestBody, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        timeout: 120000 // 2 minute timeout\n      });\n      console.timeEnd('Gemini API Call');\n      console.log('API response status:', response.status);\n      console.log('API response data keys:', Object.keys(response.data || {}));\n      console.log('Full API response data:', JSON.stringify(response.data, null, 2));\n      if (!response.data) {\n        console.error('Response data is null/undefined');\n        throw new Error('No data in API response');\n      }\n      if (!response.data.candidates || !Array.isArray(response.data.candidates)) {\n        console.error('Missing candidates field in response');\n        console.log('Available fields:', Object.keys(response.data));\n        throw new Error('No candidates field in API response');\n      }\n      if (response.data.candidates.length === 0) {\n        console.error('Candidates array is empty');\n        throw new Error('No candidates in API response');\n      }\n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || !Array.isArray(candidate.content.parts)) {\n        console.error('Invalid candidate structure');\n        console.log('Candidate structure:', JSON.stringify(candidate, null, 2));\n        throw new Error('Invalid candidate content structure');\n      }\n      if (candidate.content.parts.length === 0 || !candidate.content.parts[0].text) {\n        console.error('No text content in candidate');\n        throw new Error('No text content in API response');\n      }\n      const textContent = candidate.content.parts[0].text;\n      console.log('Successfully extracted text, length:', textContent.length);\n      console.log('Text preview:', textContent.substring(0, 200) + '...');\n      return textContent;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3, _error$response4, _error$response5, _error$response6, _error$response7, _error$response9, _error$response9$data, _error$response9$data2;\n      console.error('=== GEMINI API ERROR ===');\n      console.error('Error type:', error.constructor.name);\n      console.error('Error message:', error.message);\n      console.error('Error code:', error.code);\n      console.error('Error status:', (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status);\n      console.error('Error status text:', (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.statusText);\n      console.error('Error response headers:', (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.headers);\n      console.error('Error response data:', JSON.stringify((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data, null, 2));\n      console.error('Is network error:', error.message.includes('Network Error'));\n      console.error('Is timeout:', error.code === 'ECONNABORTED');\n      console.error('Full error stack:', error.stack);\n      console.error('===========================');\n      if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out - please try again');\n      }\n      if (error.message.includes('Network Error')) {\n        throw new Error('Network error connecting to Gemini API. Please check your internet connection.');\n      }\n      if (((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) === 401) {\n        throw new Error('Invalid API key. Please check your Gemini API key configuration.');\n      }\n      if (((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) === 429) {\n        throw new Error('Rate limit exceeded. Please wait a moment and try again.');\n      }\n      if (((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.status) === 400) {\n        var _error$response8, _error$response8$data, _error$response8$data2;\n        throw new Error(`Bad request: ${((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : (_error$response8$data = _error$response8.data) === null || _error$response8$data === void 0 ? void 0 : (_error$response8$data2 = _error$response8$data.error) === null || _error$response8$data2 === void 0 ? void 0 : _error$response8$data2.message) || 'Invalid request format'}`);\n      }\n      const errorMessage = ((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : (_error$response9$data = _error$response9.data) === null || _error$response9$data === void 0 ? void 0 : (_error$response9$data2 = _error$response9$data.error) === null || _error$response9$data2 === void 0 ? void 0 : _error$response9$data2.message) || error.message || 'Failed to generate content';\n      throw new Error(errorMessage);\n    }\n  }\n  async synthesizeSpeechWithGemini(text, speaker = 'Alex', useProModel = false) {\n    console.log('=== GEMINI NATIVE TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Speaker:', speaker);\n    console.log('Using Pro model:', useProModel);\n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    try {\n      // Voice mapping for different speakers\n      const voiceMap = {\n        'Alex': 'Kore',\n        // Professional, analytical voice\n        'Jordan': 'Zephyr',\n        // Bright, casual voice\n        'narrator': 'Puck',\n        // Upbeat narrator voice\n        'host': 'Kore',\n        'co_host': 'Zephyr',\n        'guest': 'Puck'\n      };\n      const voiceName = voiceMap[speaker] || 'Kore';\n      const apiUrl = useProModel ? GEMINI_PRO_TTS_API_URL : GEMINI_TTS_API_URL;\n\n      // Create stylistic prompt for natural delivery\n      const stylePrompt = this.getStylePromptForSpeaker(speaker);\n      const fullPrompt = `${stylePrompt}: ${text}`;\n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: fullPrompt\n          }]\n        }],\n        generationConfig: {\n          responseModalities: ['AUDIO'],\n          speechConfig: {\n            voiceConfig: {\n              prebuiltVoiceConfig: {\n                voiceName: voiceName\n              }\n            }\n          }\n        }\n      };\n      console.log('Making Gemini TTS request with voice:', voiceName);\n      const response = await axios.post(`${apiUrl}?key=${GEMINI_API_KEY}`, requestBody, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        timeout: 120000 // 2 minute timeout for TTS\n      });\n      console.log('Gemini TTS response status:', response.status);\n      console.log('Response keys:', Object.keys(response.data || {}));\n      if (!response.data || !response.data.candidates || response.data.candidates.length === 0) {\n        throw new Error('No audio content in Gemini TTS response');\n      }\n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {\n        throw new Error('Invalid audio response structure');\n      }\n\n      // Look for audio data in the response\n      const audioPart = candidate.content.parts.find(part => {\n        var _part$inlineData$mime;\n        return part.inlineData && ((_part$inlineData$mime = part.inlineData.mimeType) === null || _part$inlineData$mime === void 0 ? void 0 : _part$inlineData$mime.includes('audio'));\n      });\n      if (!audioPart || !audioPart.inlineData || !audioPart.inlineData.data) {\n        throw new Error('No audio data found in Gemini TTS response');\n      }\n\n      // Convert base64 audio to blob URL\n      const audioBase64 = audioPart.inlineData.data;\n      const mimeType = audioPart.inlineData.mimeType || 'audio/wav';\n      const audioBytes = atob(audioBase64);\n      const uint8Array = new Uint8Array(audioBytes.length);\n      for (let i = 0; i < audioBytes.length; i++) {\n        uint8Array[i] = audioBytes.charCodeAt(i);\n      }\n      const audioBlob = new Blob([uint8Array], {\n        type: mimeType\n      });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      console.log('✅ Gemini TTS synthesis successful, audio URL created');\n      console.log('Audio format:', mimeType);\n      console.log('Audio size:', audioBlob.size, 'bytes');\n      return audioUrl;\n    } catch (error) {\n      var _error$response0, _error$response1, _error$response1$data, _error$response1$data2;\n      console.error('❌ Gemini TTS synthesis failed:', error);\n      console.error('Error response:', (_error$response0 = error.response) === null || _error$response0 === void 0 ? void 0 : _error$response0.data);\n      throw new Error(`Gemini TTS failed: ${((_error$response1 = error.response) === null || _error$response1 === void 0 ? void 0 : (_error$response1$data = _error$response1.data) === null || _error$response1$data === void 0 ? void 0 : (_error$response1$data2 = _error$response1$data.error) === null || _error$response1$data2 === void 0 ? void 0 : _error$response1$data2.message) || error.message}`);\n    }\n  }\n  getStylePromptForSpeaker(speaker) {\n    const styleMap = {\n      'Alex': 'Say in a professional, analytical tone',\n      'Jordan': 'Say in a casual, friendly, storytelling tone',\n      'narrator': 'Say in a clear, engaging narrator voice',\n      'host': 'Say as a podcast host with enthusiasm',\n      'co_host': 'Say as a knowledgeable co-host',\n      'guest': 'Say as an expert guest speaker'\n    };\n    return styleMap[speaker] || 'Say naturally';\n  }\n  parseScriptForVoices(script) {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments = [];\n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({\n          speaker,\n          text: text.trim()\n        });\n      }\n    }\n    return segments;\n  }\n  async generateAudio(podcastScript) {\n    var _podcastScript$script;\n    console.log('=== ATTEMPTING REAL AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', ((_podcastScript$script = podcastScript.script) === null || _podcastScript$script === void 0 ? void 0 : _podcastScript$script.length) || 0);\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Try Google TTS via backend first\n    try {\n      console.log('🎯 Attempting Google TTS via backend...');\n      return await backendTTSService.generateAudio(podcastScript);\n    } catch (backendError) {\n      console.warn('Backend TTS failed, trying ElevenLabs fallback...');\n      console.warn('Backend error:', backendError.message);\n\n      // Fallback to ElevenLabs if backend fails\n      try {\n        console.log('🔄 Falling back to ElevenLabs...');\n        return await elevenLabsService.generateAudio(podcastScript);\n      } catch (elevenLabsError) {\n        console.error('Both TTS services failed');\n\n        // Provide helpful error messages\n        let errorMessage = 'Audio generation failed. ';\n        if (backendError.message.includes('not running')) {\n          errorMessage += 'Backend TTS server is not running. Start it with: cd tts-backend && npm start. ';\n        } else {\n          errorMessage += `Backend TTS: ${backendError.message}. `;\n        }\n        if (elevenLabsError.message.includes('API key')) {\n          errorMessage += 'ElevenLabs API key also missing. Add REACT_APP_ELEVENLABS_API_KEY to .env.local';\n        } else {\n          errorMessage += `ElevenLabs: ${elevenLabsError.message}`;\n        }\n        throw new Error(errorMessage);\n      }\n    }\n  }\n  async generateAudioWithGeminiTTS(podcastScript) {\n    console.log('=== GEMINI NATIVE TTS GENERATION ===');\n    const segments = this.parseScriptForVoices(podcastScript.script);\n    console.log(`Found ${segments.length} speaker segments`);\n    if (segments.length === 0) {\n      // No speaker segments found, treat as single narrator\n      console.log('No speaker segments found, using single voice');\n      const audioUrl = await this.synthesizeSpeechWithGemini(podcastScript.script, 'narrator', false);\n      return {\n        audioUrl,\n        duration: Math.ceil(podcastScript.script.length / 150),\n        // Rough estimate\n        format: 'audio/wav',\n        size: 0,\n        // Will be calculated when blob is created\n        transcript: podcastScript.script\n      };\n    }\n\n    // Multi-speaker generation\n    if (segments.length === 1) {\n      // Single speaker, use basic TTS\n      const segment = segments[0];\n      const audioUrl = await this.synthesizeSpeechWithGemini(segment.text, segment.speaker, false);\n      return {\n        audioUrl,\n        duration: Math.ceil(segment.text.length / 150),\n        format: 'audio/wav',\n        size: 0,\n        transcript: segment.text\n      };\n    }\n\n    // Multiple speakers - use Pro model for better multi-speaker support\n    console.log('Using Gemini Pro model for multi-speaker generation');\n\n    // Combine segments with speaker annotations for Gemini\n    const combinedScript = segments.map(seg => `${this.getStylePromptForSpeaker(seg.speaker)}: ${seg.text}`).join('\\n\\n');\n    const audioUrl = await this.synthesizeSpeechWithGemini(combinedScript, 'multi-speaker', true);\n    return {\n      audioUrl,\n      duration: Math.ceil(combinedScript.length / 150),\n      format: 'audio/wav',\n      size: 0,\n      transcript: segments.map(seg => `${seg.speaker}: ${seg.text}`).join('\\n')\n    };\n  }\n}\nexport const geminiService = new GeminiService();","map":{"version":3,"names":["axios","elevenLabsService","backendTTSService","GEMINI_API_KEY","process","env","REACT_APP_GEMINI_API_KEY","GEMINI_TTS_API_URL","GEMINI_PRO_TTS_API_URL","GOOGLE_TTS_API_URL","GeminiService","makeRequest","prompt","console","log","length","substring","Error","time","requestBody","contents","parts","text","generationConfig","temperature","topK","topP","maxOutputTokens","response","post","headers","timeout","timeEnd","status","Object","keys","data","JSON","stringify","error","candidates","Array","isArray","candidate","content","textContent","_error$response","_error$response2","_error$response3","_error$response4","_error$response5","_error$response6","_error$response7","_error$response9","_error$response9$data","_error$response9$data2","constructor","name","message","code","statusText","includes","stack","_error$response8","_error$response8$data","_error$response8$data2","errorMessage","synthesizeSpeechWithGemini","speaker","useProModel","voiceMap","voiceName","apiUrl","stylePrompt","getStylePromptForSpeaker","fullPrompt","responseModalities","speechConfig","voiceConfig","prebuiltVoiceConfig","audioPart","find","part","_part$inlineData$mime","inlineData","mimeType","audioBase64","audioBytes","atob","uint8Array","Uint8Array","i","charCodeAt","audioBlob","Blob","type","audioUrl","URL","createObjectURL","size","_error$response0","_error$response1","_error$response1$data","_error$response1$data2","styleMap","parseScriptForVoices","script","lines","split","filter","line","trim","segments","match","push","generateAudio","podcastScript","_podcastScript$script","title","backendError","warn","elevenLabsError","generateAudioWithGeminiTTS","duration","Math","ceil","format","transcript","segment","combinedScript","map","seg","join","geminiService"],"sources":["/Users/will/Content Creation App/src/services/ai/gemini.service.ts"],"sourcesContent":["// services/ai/gemini.service.ts\nimport axios from 'axios';\nimport { PodcastContent } from '../../types/project.types';\nimport { elevenLabsService } from './elevenlabs.service';\nimport { backendTTSService } from './backend-tts.service';\n\nconst GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nconst GEMINI_TTS_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';\nconst GEMINI_PRO_TTS_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-tts:generateContent';\nconst GOOGLE_TTS_API_URL = 'https://texttospeech.googleapis.com/v1/text:synthesize';\n\nexport interface AudioContent {\n  audioUrl: string;\n  duration: number;\n  format: string;\n  size: number;\n  transcript: string;\n}\n\nexport class GeminiService {\n  private async makeRequest(prompt: string): Promise<string> {\n    console.log('=== GEMINI API REQUEST ===');\n    console.log('API Key exists:', !!GEMINI_API_KEY);\n    console.log('API Key length:', GEMINI_API_KEY?.length || 0);\n    console.log('API Key preview:', GEMINI_API_KEY?.substring(0, 10) + '...' || 'None');\n    console.log('API URL:', GEMINI_TTS_API_URL);\n    console.log('Prompt length:', prompt.length);\n    \n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    \n    try {\n      console.time('Gemini API Call');\n      \n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 4096,\n        }\n      };\n      \n      console.log('Request body prepared for Gemini API');\n      \n      const response = await axios.post(\n        `${GEMINI_TTS_API_URL}?key=${GEMINI_API_KEY}`,\n        requestBody,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          timeout: 120000, // 2 minute timeout\n        }\n      );\n\n      console.timeEnd('Gemini API Call');\n      console.log('API response status:', response.status);\n      console.log('API response data keys:', Object.keys(response.data || {}));\n      console.log('Full API response data:', JSON.stringify(response.data, null, 2));\n      \n      if (!response.data) {\n        console.error('Response data is null/undefined');\n        throw new Error('No data in API response');\n      }\n      \n      if (!response.data.candidates || !Array.isArray(response.data.candidates)) {\n        console.error('Missing candidates field in response');\n        console.log('Available fields:', Object.keys(response.data));\n        throw new Error('No candidates field in API response');\n      }\n      \n      if (response.data.candidates.length === 0) {\n        console.error('Candidates array is empty');\n        throw new Error('No candidates in API response');\n      }\n      \n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || !Array.isArray(candidate.content.parts)) {\n        console.error('Invalid candidate structure');\n        console.log('Candidate structure:', JSON.stringify(candidate, null, 2));\n        throw new Error('Invalid candidate content structure');\n      }\n      \n      if (candidate.content.parts.length === 0 || !candidate.content.parts[0].text) {\n        console.error('No text content in candidate');\n        throw new Error('No text content in API response');\n      }\n      \n      const textContent = candidate.content.parts[0].text;\n      console.log('Successfully extracted text, length:', textContent.length);\n      console.log('Text preview:', textContent.substring(0, 200) + '...');\n      return textContent;\n    } catch (error: any) {\n      console.error('=== GEMINI API ERROR ===');\n      console.error('Error type:', error.constructor.name);\n      console.error('Error message:', error.message);\n      console.error('Error code:', error.code);\n      console.error('Error status:', error.response?.status);\n      console.error('Error status text:', error.response?.statusText);\n      console.error('Error response headers:', error.response?.headers);\n      console.error('Error response data:', JSON.stringify(error.response?.data, null, 2));\n      console.error('Is network error:', error.message.includes('Network Error'));\n      console.error('Is timeout:', error.code === 'ECONNABORTED');\n      console.error('Full error stack:', error.stack);\n      console.error('===========================');\n      \n      if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out - please try again');\n      }\n      \n      if (error.message.includes('Network Error')) {\n        throw new Error('Network error connecting to Gemini API. Please check your internet connection.');\n      }\n      \n      if (error.response?.status === 401) {\n        throw new Error('Invalid API key. Please check your Gemini API key configuration.');\n      }\n      \n      if (error.response?.status === 429) {\n        throw new Error('Rate limit exceeded. Please wait a moment and try again.');\n      }\n      \n      if (error.response?.status === 400) {\n        throw new Error(`Bad request: ${error.response?.data?.error?.message || 'Invalid request format'}`);\n      }\n      \n      const errorMessage = error.response?.data?.error?.message || error.message || 'Failed to generate content';\n      throw new Error(errorMessage);\n    }\n  }\n\n  private async synthesizeSpeechWithGemini(text: string, speaker: string = 'Alex', useProModel: boolean = false): Promise<string> {\n    console.log('=== GEMINI NATIVE TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Speaker:', speaker);\n    console.log('Using Pro model:', useProModel);\n    \n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    \n    try {\n      // Voice mapping for different speakers\n      const voiceMap: { [key: string]: string } = {\n        'Alex': 'Kore',     // Professional, analytical voice\n        'Jordan': 'Zephyr', // Bright, casual voice\n        'narrator': 'Puck', // Upbeat narrator voice\n        'host': 'Kore',\n        'co_host': 'Zephyr',\n        'guest': 'Puck'\n      };\n      \n      const voiceName = voiceMap[speaker] || 'Kore';\n      const apiUrl = useProModel ? GEMINI_PRO_TTS_API_URL : GEMINI_TTS_API_URL;\n      \n      // Create stylistic prompt for natural delivery\n      const stylePrompt = this.getStylePromptForSpeaker(speaker);\n      const fullPrompt = `${stylePrompt}: ${text}`;\n      \n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: fullPrompt\n          }]\n        }],\n        generationConfig: {\n          responseModalities: ['AUDIO'],\n          speechConfig: {\n            voiceConfig: {\n              prebuiltVoiceConfig: {\n                voiceName: voiceName\n              }\n            }\n          }\n        }\n      };\n      \n      console.log('Making Gemini TTS request with voice:', voiceName);\n      \n      const response = await axios.post(\n        `${apiUrl}?key=${GEMINI_API_KEY}`,\n        requestBody,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          timeout: 120000, // 2 minute timeout for TTS\n        }\n      );\n      \n      console.log('Gemini TTS response status:', response.status);\n      console.log('Response keys:', Object.keys(response.data || {}));\n      \n      if (!response.data || !response.data.candidates || response.data.candidates.length === 0) {\n        throw new Error('No audio content in Gemini TTS response');\n      }\n      \n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {\n        throw new Error('Invalid audio response structure');\n      }\n      \n      // Look for audio data in the response\n      const audioPart = candidate.content.parts.find((part: any) => part.inlineData && part.inlineData.mimeType?.includes('audio'));\n      \n      if (!audioPart || !audioPart.inlineData || !audioPart.inlineData.data) {\n        throw new Error('No audio data found in Gemini TTS response');\n      }\n      \n      // Convert base64 audio to blob URL\n      const audioBase64 = audioPart.inlineData.data;\n      const mimeType = audioPart.inlineData.mimeType || 'audio/wav';\n      \n      const audioBytes = atob(audioBase64);\n      const uint8Array = new Uint8Array(audioBytes.length);\n      for (let i = 0; i < audioBytes.length; i++) {\n        uint8Array[i] = audioBytes.charCodeAt(i);\n      }\n      \n      const audioBlob = new Blob([uint8Array], { type: mimeType });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      \n      console.log('✅ Gemini TTS synthesis successful, audio URL created');\n      console.log('Audio format:', mimeType);\n      console.log('Audio size:', audioBlob.size, 'bytes');\n      \n      return audioUrl;\n    } catch (error: any) {\n      console.error('❌ Gemini TTS synthesis failed:', error);\n      console.error('Error response:', error.response?.data);\n      throw new Error(`Gemini TTS failed: ${error.response?.data?.error?.message || error.message}`);\n    }\n  }\n  \n  private getStylePromptForSpeaker(speaker: string): string {\n    const styleMap: { [key: string]: string } = {\n      'Alex': 'Say in a professional, analytical tone',\n      'Jordan': 'Say in a casual, friendly, storytelling tone',\n      'narrator': 'Say in a clear, engaging narrator voice',\n      'host': 'Say as a podcast host with enthusiasm',\n      'co_host': 'Say as a knowledgeable co-host',\n      'guest': 'Say as an expert guest speaker'\n    };\n    \n    return styleMap[speaker] || 'Say naturally';\n  }\n\n  private parseScriptForVoices(script: string): Array<{speaker: string, text: string}> {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments: Array<{speaker: string, text: string}> = [];\n    \n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({ speaker, text: text.trim() });\n      }\n    }\n    \n    return segments;\n  }\n\n  async generateAudio(podcastScript: PodcastContent): Promise<AudioContent> {\n    console.log('=== ATTEMPTING REAL AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', podcastScript.script?.length || 0);\n\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Try Google TTS via backend first\n    try {\n      console.log('🎯 Attempting Google TTS via backend...');\n      return await backendTTSService.generateAudio(podcastScript);\n    } catch (backendError: any) {\n      console.warn('Backend TTS failed, trying ElevenLabs fallback...');\n      console.warn('Backend error:', backendError.message);\n      \n      // Fallback to ElevenLabs if backend fails\n      try {\n        console.log('🔄 Falling back to ElevenLabs...');\n        return await elevenLabsService.generateAudio(podcastScript);\n      } catch (elevenLabsError: any) {\n        console.error('Both TTS services failed');\n        \n        // Provide helpful error messages\n        let errorMessage = 'Audio generation failed. ';\n        \n        if (backendError.message.includes('not running')) {\n          errorMessage += 'Backend TTS server is not running. Start it with: cd tts-backend && npm start. ';\n        } else {\n          errorMessage += `Backend TTS: ${backendError.message}. `;\n        }\n        \n        if (elevenLabsError.message.includes('API key')) {\n          errorMessage += 'ElevenLabs API key also missing. Add REACT_APP_ELEVENLABS_API_KEY to .env.local';\n        } else {\n          errorMessage += `ElevenLabs: ${elevenLabsError.message}`;\n        }\n        \n        throw new Error(errorMessage);\n      }\n    }\n  }\n  \n  private async generateAudioWithGeminiTTS(podcastScript: PodcastContent): Promise<AudioContent> {\n    console.log('=== GEMINI NATIVE TTS GENERATION ===');\n    \n    const segments = this.parseScriptForVoices(podcastScript.script!);\n    console.log(`Found ${segments.length} speaker segments`);\n    \n    if (segments.length === 0) {\n      // No speaker segments found, treat as single narrator\n      console.log('No speaker segments found, using single voice');\n      const audioUrl = await this.synthesizeSpeechWithGemini(podcastScript.script!, 'narrator', false);\n      \n      return {\n        audioUrl,\n        duration: Math.ceil(podcastScript.script!.length / 150), // Rough estimate\n        format: 'audio/wav',\n        size: 0, // Will be calculated when blob is created\n        transcript: podcastScript.script!\n      };\n    }\n    \n    // Multi-speaker generation\n    if (segments.length === 1) {\n      // Single speaker, use basic TTS\n      const segment = segments[0];\n      const audioUrl = await this.synthesizeSpeechWithGemini(segment.text, segment.speaker, false);\n      \n      return {\n        audioUrl,\n        duration: Math.ceil(segment.text.length / 150),\n        format: 'audio/wav',\n        size: 0,\n        transcript: segment.text\n      };\n    }\n    \n    // Multiple speakers - use Pro model for better multi-speaker support\n    console.log('Using Gemini Pro model for multi-speaker generation');\n    \n    // Combine segments with speaker annotations for Gemini\n    const combinedScript = segments.map(seg => \n      `${this.getStylePromptForSpeaker(seg.speaker)}: ${seg.text}`\n    ).join('\\n\\n');\n    \n    const audioUrl = await this.synthesizeSpeechWithGemini(combinedScript, 'multi-speaker', true);\n    \n    return {\n      audioUrl,\n      duration: Math.ceil(combinedScript.length / 150),\n      format: 'audio/wav',\n      size: 0,\n      transcript: segments.map(seg => `${seg.speaker}: ${seg.text}`).join('\\n')\n    };\n  }\n}\n\nexport const geminiService = new GeminiService();"],"mappings":"AAAA;AACA,OAAOA,KAAK,MAAM,OAAO;AAEzB,SAASC,iBAAiB,QAAQ,sBAAsB;AACxD,SAASC,iBAAiB,QAAQ,uBAAuB;AAEzD,MAAMC,cAAc,GAAGC,OAAO,CAACC,GAAG,CAACC,wBAAwB;AAC3D,MAAMC,kBAAkB,GAAG,sGAAsG;AACjI,MAAMC,sBAAsB,GAAG,oGAAoG;AACnI,MAAMC,kBAAkB,GAAG,wDAAwD;AAUnF,OAAO,MAAMC,aAAa,CAAC;EACzB,MAAcC,WAAWA,CAACC,MAAc,EAAmB;IACzDC,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;IACzCD,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAE,CAAC,CAACX,cAAc,CAAC;IAChDU,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAE,CAAAX,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEY,MAAM,KAAI,CAAC,CAAC;IAC3DF,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAE,CAAAX,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEa,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,IAAG,KAAK,IAAI,MAAM,CAAC;IACnFH,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEP,kBAAkB,CAAC;IAC3CM,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEF,MAAM,CAACG,MAAM,CAAC;IAE5C,IAAI,CAACZ,cAAc,EAAE;MACnB,MAAM,IAAIc,KAAK,CAAC,0FAA0F,CAAC;IAC7G;IAEA,IAAI;MACFJ,OAAO,CAACK,IAAI,CAAC,iBAAiB,CAAC;MAE/B,MAAMC,WAAW,GAAG;QAClBC,QAAQ,EAAE,CAAC;UACTC,KAAK,EAAE,CAAC;YACNC,IAAI,EAAEV;UACR,CAAC;QACH,CAAC,CAAC;QACFW,gBAAgB,EAAE;UAChBC,WAAW,EAAE,GAAG;UAChBC,IAAI,EAAE,EAAE;UACRC,IAAI,EAAE,IAAI;UACVC,eAAe,EAAE;QACnB;MACF,CAAC;MAEDd,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;MAEnD,MAAMc,QAAQ,GAAG,MAAM5B,KAAK,CAAC6B,IAAI,CAC/B,GAAGtB,kBAAkB,QAAQJ,cAAc,EAAE,EAC7CgB,WAAW,EACX;QACEW,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,OAAO,EAAE,MAAM,CAAE;MACnB,CACF,CAAC;MAEDlB,OAAO,CAACmB,OAAO,CAAC,iBAAiB,CAAC;MAClCnB,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEc,QAAQ,CAACK,MAAM,CAAC;MACpDpB,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEoB,MAAM,CAACC,IAAI,CAACP,QAAQ,CAACQ,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC;MACxEvB,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEuB,IAAI,CAACC,SAAS,CAACV,QAAQ,CAACQ,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;MAE9E,IAAI,CAACR,QAAQ,CAACQ,IAAI,EAAE;QAClBvB,OAAO,CAAC0B,KAAK,CAAC,iCAAiC,CAAC;QAChD,MAAM,IAAItB,KAAK,CAAC,yBAAyB,CAAC;MAC5C;MAEA,IAAI,CAACW,QAAQ,CAACQ,IAAI,CAACI,UAAU,IAAI,CAACC,KAAK,CAACC,OAAO,CAACd,QAAQ,CAACQ,IAAI,CAACI,UAAU,CAAC,EAAE;QACzE3B,OAAO,CAAC0B,KAAK,CAAC,sCAAsC,CAAC;QACrD1B,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAEoB,MAAM,CAACC,IAAI,CAACP,QAAQ,CAACQ,IAAI,CAAC,CAAC;QAC5D,MAAM,IAAInB,KAAK,CAAC,qCAAqC,CAAC;MACxD;MAEA,IAAIW,QAAQ,CAACQ,IAAI,CAACI,UAAU,CAACzB,MAAM,KAAK,CAAC,EAAE;QACzCF,OAAO,CAAC0B,KAAK,CAAC,2BAA2B,CAAC;QAC1C,MAAM,IAAItB,KAAK,CAAC,+BAA+B,CAAC;MAClD;MAEA,MAAM0B,SAAS,GAAGf,QAAQ,CAACQ,IAAI,CAACI,UAAU,CAAC,CAAC,CAAC;MAC7C,IAAI,CAACG,SAAS,CAACC,OAAO,IAAI,CAACD,SAAS,CAACC,OAAO,CAACvB,KAAK,IAAI,CAACoB,KAAK,CAACC,OAAO,CAACC,SAAS,CAACC,OAAO,CAACvB,KAAK,CAAC,EAAE;QAC7FR,OAAO,CAAC0B,KAAK,CAAC,6BAA6B,CAAC;QAC5C1B,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEuB,IAAI,CAACC,SAAS,CAACK,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;QACvE,MAAM,IAAI1B,KAAK,CAAC,qCAAqC,CAAC;MACxD;MAEA,IAAI0B,SAAS,CAACC,OAAO,CAACvB,KAAK,CAACN,MAAM,KAAK,CAAC,IAAI,CAAC4B,SAAS,CAACC,OAAO,CAACvB,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,EAAE;QAC5ET,OAAO,CAAC0B,KAAK,CAAC,8BAA8B,CAAC;QAC7C,MAAM,IAAItB,KAAK,CAAC,iCAAiC,CAAC;MACpD;MAEA,MAAM4B,WAAW,GAAGF,SAAS,CAACC,OAAO,CAACvB,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI;MACnDT,OAAO,CAACC,GAAG,CAAC,sCAAsC,EAAE+B,WAAW,CAAC9B,MAAM,CAAC;MACvEF,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE+B,WAAW,CAAC7B,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC;MACnE,OAAO6B,WAAW;IACpB,CAAC,CAAC,OAAON,KAAU,EAAE;MAAA,IAAAO,eAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,qBAAA,EAAAC,sBAAA;MACnB1C,OAAO,CAAC0B,KAAK,CAAC,0BAA0B,CAAC;MACzC1B,OAAO,CAAC0B,KAAK,CAAC,aAAa,EAAEA,KAAK,CAACiB,WAAW,CAACC,IAAI,CAAC;MACpD5C,OAAO,CAAC0B,KAAK,CAAC,gBAAgB,EAAEA,KAAK,CAACmB,OAAO,CAAC;MAC9C7C,OAAO,CAAC0B,KAAK,CAAC,aAAa,EAAEA,KAAK,CAACoB,IAAI,CAAC;MACxC9C,OAAO,CAAC0B,KAAK,CAAC,eAAe,GAAAO,eAAA,GAAEP,KAAK,CAACX,QAAQ,cAAAkB,eAAA,uBAAdA,eAAA,CAAgBb,MAAM,CAAC;MACtDpB,OAAO,CAAC0B,KAAK,CAAC,oBAAoB,GAAAQ,gBAAA,GAAER,KAAK,CAACX,QAAQ,cAAAmB,gBAAA,uBAAdA,gBAAA,CAAgBa,UAAU,CAAC;MAC/D/C,OAAO,CAAC0B,KAAK,CAAC,yBAAyB,GAAAS,gBAAA,GAAET,KAAK,CAACX,QAAQ,cAAAoB,gBAAA,uBAAdA,gBAAA,CAAgBlB,OAAO,CAAC;MACjEjB,OAAO,CAAC0B,KAAK,CAAC,sBAAsB,EAAEF,IAAI,CAACC,SAAS,EAAAW,gBAAA,GAACV,KAAK,CAACX,QAAQ,cAAAqB,gBAAA,uBAAdA,gBAAA,CAAgBb,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;MACpFvB,OAAO,CAAC0B,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAACmB,OAAO,CAACG,QAAQ,CAAC,eAAe,CAAC,CAAC;MAC3EhD,OAAO,CAAC0B,KAAK,CAAC,aAAa,EAAEA,KAAK,CAACoB,IAAI,KAAK,cAAc,CAAC;MAC3D9C,OAAO,CAAC0B,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAACuB,KAAK,CAAC;MAC/CjD,OAAO,CAAC0B,KAAK,CAAC,6BAA6B,CAAC;MAE5C,IAAIA,KAAK,CAACoB,IAAI,KAAK,cAAc,EAAE;QACjC,MAAM,IAAI1C,KAAK,CAAC,sCAAsC,CAAC;MACzD;MAEA,IAAIsB,KAAK,CAACmB,OAAO,CAACG,QAAQ,CAAC,eAAe,CAAC,EAAE;QAC3C,MAAM,IAAI5C,KAAK,CAAC,gFAAgF,CAAC;MACnG;MAEA,IAAI,EAAAiC,gBAAA,GAAAX,KAAK,CAACX,QAAQ,cAAAsB,gBAAA,uBAAdA,gBAAA,CAAgBjB,MAAM,MAAK,GAAG,EAAE;QAClC,MAAM,IAAIhB,KAAK,CAAC,kEAAkE,CAAC;MACrF;MAEA,IAAI,EAAAkC,gBAAA,GAAAZ,KAAK,CAACX,QAAQ,cAAAuB,gBAAA,uBAAdA,gBAAA,CAAgBlB,MAAM,MAAK,GAAG,EAAE;QAClC,MAAM,IAAIhB,KAAK,CAAC,0DAA0D,CAAC;MAC7E;MAEA,IAAI,EAAAmC,gBAAA,GAAAb,KAAK,CAACX,QAAQ,cAAAwB,gBAAA,uBAAdA,gBAAA,CAAgBnB,MAAM,MAAK,GAAG,EAAE;QAAA,IAAA8B,gBAAA,EAAAC,qBAAA,EAAAC,sBAAA;QAClC,MAAM,IAAIhD,KAAK,CAAC,gBAAgB,EAAA8C,gBAAA,GAAAxB,KAAK,CAACX,QAAQ,cAAAmC,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgB3B,IAAI,cAAA4B,qBAAA,wBAAAC,sBAAA,GAApBD,qBAAA,CAAsBzB,KAAK,cAAA0B,sBAAA,uBAA3BA,sBAAA,CAA6BP,OAAO,KAAI,wBAAwB,EAAE,CAAC;MACrG;MAEA,MAAMQ,YAAY,GAAG,EAAAb,gBAAA,GAAAd,KAAK,CAACX,QAAQ,cAAAyB,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgBjB,IAAI,cAAAkB,qBAAA,wBAAAC,sBAAA,GAApBD,qBAAA,CAAsBf,KAAK,cAAAgB,sBAAA,uBAA3BA,sBAAA,CAA6BG,OAAO,KAAInB,KAAK,CAACmB,OAAO,IAAI,4BAA4B;MAC1G,MAAM,IAAIzC,KAAK,CAACiD,YAAY,CAAC;IAC/B;EACF;EAEA,MAAcC,0BAA0BA,CAAC7C,IAAY,EAAE8C,OAAe,GAAG,MAAM,EAAEC,WAAoB,GAAG,KAAK,EAAmB;IAC9HxD,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;IAChDD,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEQ,IAAI,CAACP,MAAM,CAAC;IACxCF,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEsD,OAAO,CAAC;IAChCvD,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEuD,WAAW,CAAC;IAE5C,IAAI,CAAClE,cAAc,EAAE;MACnB,MAAM,IAAIc,KAAK,CAAC,0FAA0F,CAAC;IAC7G;IAEA,IAAI;MACF;MACA,MAAMqD,QAAmC,GAAG;QAC1C,MAAM,EAAE,MAAM;QAAM;QACpB,QAAQ,EAAE,QAAQ;QAAE;QACpB,UAAU,EAAE,MAAM;QAAE;QACpB,MAAM,EAAE,MAAM;QACd,SAAS,EAAE,QAAQ;QACnB,OAAO,EAAE;MACX,CAAC;MAED,MAAMC,SAAS,GAAGD,QAAQ,CAACF,OAAO,CAAC,IAAI,MAAM;MAC7C,MAAMI,MAAM,GAAGH,WAAW,GAAG7D,sBAAsB,GAAGD,kBAAkB;;MAExE;MACA,MAAMkE,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACN,OAAO,CAAC;MAC1D,MAAMO,UAAU,GAAG,GAAGF,WAAW,KAAKnD,IAAI,EAAE;MAE5C,MAAMH,WAAW,GAAG;QAClBC,QAAQ,EAAE,CAAC;UACTC,KAAK,EAAE,CAAC;YACNC,IAAI,EAAEqD;UACR,CAAC;QACH,CAAC,CAAC;QACFpD,gBAAgB,EAAE;UAChBqD,kBAAkB,EAAE,CAAC,OAAO,CAAC;UAC7BC,YAAY,EAAE;YACZC,WAAW,EAAE;cACXC,mBAAmB,EAAE;gBACnBR,SAAS,EAAEA;cACb;YACF;UACF;QACF;MACF,CAAC;MAED1D,OAAO,CAACC,GAAG,CAAC,uCAAuC,EAAEyD,SAAS,CAAC;MAE/D,MAAM3C,QAAQ,GAAG,MAAM5B,KAAK,CAAC6B,IAAI,CAC/B,GAAG2C,MAAM,QAAQrE,cAAc,EAAE,EACjCgB,WAAW,EACX;QACEW,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,OAAO,EAAE,MAAM,CAAE;MACnB,CACF,CAAC;MAEDlB,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEc,QAAQ,CAACK,MAAM,CAAC;MAC3DpB,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEoB,MAAM,CAACC,IAAI,CAACP,QAAQ,CAACQ,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC;MAE/D,IAAI,CAACR,QAAQ,CAACQ,IAAI,IAAI,CAACR,QAAQ,CAACQ,IAAI,CAACI,UAAU,IAAIZ,QAAQ,CAACQ,IAAI,CAACI,UAAU,CAACzB,MAAM,KAAK,CAAC,EAAE;QACxF,MAAM,IAAIE,KAAK,CAAC,yCAAyC,CAAC;MAC5D;MAEA,MAAM0B,SAAS,GAAGf,QAAQ,CAACQ,IAAI,CAACI,UAAU,CAAC,CAAC,CAAC;MAC7C,IAAI,CAACG,SAAS,CAACC,OAAO,IAAI,CAACD,SAAS,CAACC,OAAO,CAACvB,KAAK,IAAIsB,SAAS,CAACC,OAAO,CAACvB,KAAK,CAACN,MAAM,KAAK,CAAC,EAAE;QAC1F,MAAM,IAAIE,KAAK,CAAC,kCAAkC,CAAC;MACrD;;MAEA;MACA,MAAM+D,SAAS,GAAGrC,SAAS,CAACC,OAAO,CAACvB,KAAK,CAAC4D,IAAI,CAAEC,IAAS;QAAA,IAAAC,qBAAA;QAAA,OAAKD,IAAI,CAACE,UAAU,MAAAD,qBAAA,GAAID,IAAI,CAACE,UAAU,CAACC,QAAQ,cAAAF,qBAAA,uBAAxBA,qBAAA,CAA0BtB,QAAQ,CAAC,OAAO,CAAC;MAAA,EAAC;MAE7H,IAAI,CAACmB,SAAS,IAAI,CAACA,SAAS,CAACI,UAAU,IAAI,CAACJ,SAAS,CAACI,UAAU,CAAChD,IAAI,EAAE;QACrE,MAAM,IAAInB,KAAK,CAAC,4CAA4C,CAAC;MAC/D;;MAEA;MACA,MAAMqE,WAAW,GAAGN,SAAS,CAACI,UAAU,CAAChD,IAAI;MAC7C,MAAMiD,QAAQ,GAAGL,SAAS,CAACI,UAAU,CAACC,QAAQ,IAAI,WAAW;MAE7D,MAAME,UAAU,GAAGC,IAAI,CAACF,WAAW,CAAC;MACpC,MAAMG,UAAU,GAAG,IAAIC,UAAU,CAACH,UAAU,CAACxE,MAAM,CAAC;MACpD,KAAK,IAAI4E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,UAAU,CAACxE,MAAM,EAAE4E,CAAC,EAAE,EAAE;QAC1CF,UAAU,CAACE,CAAC,CAAC,GAAGJ,UAAU,CAACK,UAAU,CAACD,CAAC,CAAC;MAC1C;MAEA,MAAME,SAAS,GAAG,IAAIC,IAAI,CAAC,CAACL,UAAU,CAAC,EAAE;QAAEM,IAAI,EAAEV;MAAS,CAAC,CAAC;MAC5D,MAAMW,QAAQ,GAAGC,GAAG,CAACC,eAAe,CAACL,SAAS,CAAC;MAE/ChF,OAAO,CAACC,GAAG,CAAC,sDAAsD,CAAC;MACnED,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEuE,QAAQ,CAAC;MACtCxE,OAAO,CAACC,GAAG,CAAC,aAAa,EAAE+E,SAAS,CAACM,IAAI,EAAE,OAAO,CAAC;MAEnD,OAAOH,QAAQ;IACjB,CAAC,CAAC,OAAOzD,KAAU,EAAE;MAAA,IAAA6D,gBAAA,EAAAC,gBAAA,EAAAC,qBAAA,EAAAC,sBAAA;MACnB1F,OAAO,CAAC0B,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtD1B,OAAO,CAAC0B,KAAK,CAAC,iBAAiB,GAAA6D,gBAAA,GAAE7D,KAAK,CAACX,QAAQ,cAAAwE,gBAAA,uBAAdA,gBAAA,CAAgBhE,IAAI,CAAC;MACtD,MAAM,IAAInB,KAAK,CAAC,sBAAsB,EAAAoF,gBAAA,GAAA9D,KAAK,CAACX,QAAQ,cAAAyE,gBAAA,wBAAAC,qBAAA,GAAdD,gBAAA,CAAgBjE,IAAI,cAAAkE,qBAAA,wBAAAC,sBAAA,GAApBD,qBAAA,CAAsB/D,KAAK,cAAAgE,sBAAA,uBAA3BA,sBAAA,CAA6B7C,OAAO,KAAInB,KAAK,CAACmB,OAAO,EAAE,CAAC;IAChG;EACF;EAEQgB,wBAAwBA,CAACN,OAAe,EAAU;IACxD,MAAMoC,QAAmC,GAAG;MAC1C,MAAM,EAAE,wCAAwC;MAChD,QAAQ,EAAE,8CAA8C;MACxD,UAAU,EAAE,yCAAyC;MACrD,MAAM,EAAE,uCAAuC;MAC/C,SAAS,EAAE,gCAAgC;MAC3C,OAAO,EAAE;IACX,CAAC;IAED,OAAOA,QAAQ,CAACpC,OAAO,CAAC,IAAI,eAAe;EAC7C;EAEQqC,oBAAoBA,CAACC,MAAc,EAA0C;IACnF,MAAMC,KAAK,GAAGD,MAAM,CAACE,KAAK,CAAC,IAAI,CAAC,CAACC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IAC5D,MAAMC,QAAgD,GAAG,EAAE;IAE3D,KAAK,MAAMF,IAAI,IAAIH,KAAK,EAAE;MACxB;MACA,MAAMM,KAAK,GAAGH,IAAI,CAACG,KAAK,CAAC,yBAAyB,CAAC;MACnD,IAAIA,KAAK,EAAE;QACT,MAAM,GAAG7C,OAAO,EAAE9C,IAAI,CAAC,GAAG2F,KAAK;QAC/BD,QAAQ,CAACE,IAAI,CAAC;UAAE9C,OAAO;UAAE9C,IAAI,EAAEA,IAAI,CAACyF,IAAI,CAAC;QAAE,CAAC,CAAC;MAC/C;IACF;IAEA,OAAOC,QAAQ;EACjB;EAEA,MAAMG,aAAaA,CAACC,aAA6B,EAAyB;IAAA,IAAAC,qBAAA;IACxExG,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;IACvDD,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEsG,aAAa,CAACE,KAAK,CAAC;IAClDzG,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAE,EAAAuG,qBAAA,GAAAD,aAAa,CAACV,MAAM,cAAAW,qBAAA,uBAApBA,qBAAA,CAAsBtG,MAAM,KAAI,CAAC,CAAC;IAEhE,IAAI,CAACqG,aAAa,CAACV,MAAM,IAAIU,aAAa,CAACV,MAAM,CAACK,IAAI,CAAC,CAAC,CAAChG,MAAM,KAAK,CAAC,EAAE;MACrE,MAAM,IAAIE,KAAK,CAAC,iDAAiD,CAAC;IACpE;;IAEA;IACA,IAAI;MACFJ,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;MACtD,OAAO,MAAMZ,iBAAiB,CAACiH,aAAa,CAACC,aAAa,CAAC;IAC7D,CAAC,CAAC,OAAOG,YAAiB,EAAE;MAC1B1G,OAAO,CAAC2G,IAAI,CAAC,mDAAmD,CAAC;MACjE3G,OAAO,CAAC2G,IAAI,CAAC,gBAAgB,EAAED,YAAY,CAAC7D,OAAO,CAAC;;MAEpD;MACA,IAAI;QACF7C,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;QAC/C,OAAO,MAAMb,iBAAiB,CAACkH,aAAa,CAACC,aAAa,CAAC;MAC7D,CAAC,CAAC,OAAOK,eAAoB,EAAE;QAC7B5G,OAAO,CAAC0B,KAAK,CAAC,0BAA0B,CAAC;;QAEzC;QACA,IAAI2B,YAAY,GAAG,2BAA2B;QAE9C,IAAIqD,YAAY,CAAC7D,OAAO,CAACG,QAAQ,CAAC,aAAa,CAAC,EAAE;UAChDK,YAAY,IAAI,iFAAiF;QACnG,CAAC,MAAM;UACLA,YAAY,IAAI,gBAAgBqD,YAAY,CAAC7D,OAAO,IAAI;QAC1D;QAEA,IAAI+D,eAAe,CAAC/D,OAAO,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;UAC/CK,YAAY,IAAI,iFAAiF;QACnG,CAAC,MAAM;UACLA,YAAY,IAAI,eAAeuD,eAAe,CAAC/D,OAAO,EAAE;QAC1D;QAEA,MAAM,IAAIzC,KAAK,CAACiD,YAAY,CAAC;MAC/B;IACF;EACF;EAEA,MAAcwD,0BAA0BA,CAACN,aAA6B,EAAyB;IAC7FvG,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;IAEnD,MAAMkG,QAAQ,GAAG,IAAI,CAACP,oBAAoB,CAACW,aAAa,CAACV,MAAO,CAAC;IACjE7F,OAAO,CAACC,GAAG,CAAC,SAASkG,QAAQ,CAACjG,MAAM,mBAAmB,CAAC;IAExD,IAAIiG,QAAQ,CAACjG,MAAM,KAAK,CAAC,EAAE;MACzB;MACAF,OAAO,CAACC,GAAG,CAAC,+CAA+C,CAAC;MAC5D,MAAMkF,QAAQ,GAAG,MAAM,IAAI,CAAC7B,0BAA0B,CAACiD,aAAa,CAACV,MAAM,EAAG,UAAU,EAAE,KAAK,CAAC;MAEhG,OAAO;QACLV,QAAQ;QACR2B,QAAQ,EAAEC,IAAI,CAACC,IAAI,CAACT,aAAa,CAACV,MAAM,CAAE3F,MAAM,GAAG,GAAG,CAAC;QAAE;QACzD+G,MAAM,EAAE,WAAW;QACnB3B,IAAI,EAAE,CAAC;QAAE;QACT4B,UAAU,EAAEX,aAAa,CAACV;MAC5B,CAAC;IACH;;IAEA;IACA,IAAIM,QAAQ,CAACjG,MAAM,KAAK,CAAC,EAAE;MACzB;MACA,MAAMiH,OAAO,GAAGhB,QAAQ,CAAC,CAAC,CAAC;MAC3B,MAAMhB,QAAQ,GAAG,MAAM,IAAI,CAAC7B,0BAA0B,CAAC6D,OAAO,CAAC1G,IAAI,EAAE0G,OAAO,CAAC5D,OAAO,EAAE,KAAK,CAAC;MAE5F,OAAO;QACL4B,QAAQ;QACR2B,QAAQ,EAAEC,IAAI,CAACC,IAAI,CAACG,OAAO,CAAC1G,IAAI,CAACP,MAAM,GAAG,GAAG,CAAC;QAC9C+G,MAAM,EAAE,WAAW;QACnB3B,IAAI,EAAE,CAAC;QACP4B,UAAU,EAAEC,OAAO,CAAC1G;MACtB,CAAC;IACH;;IAEA;IACAT,OAAO,CAACC,GAAG,CAAC,qDAAqD,CAAC;;IAElE;IACA,MAAMmH,cAAc,GAAGjB,QAAQ,CAACkB,GAAG,CAACC,GAAG,IACrC,GAAG,IAAI,CAACzD,wBAAwB,CAACyD,GAAG,CAAC/D,OAAO,CAAC,KAAK+D,GAAG,CAAC7G,IAAI,EAC5D,CAAC,CAAC8G,IAAI,CAAC,MAAM,CAAC;IAEd,MAAMpC,QAAQ,GAAG,MAAM,IAAI,CAAC7B,0BAA0B,CAAC8D,cAAc,EAAE,eAAe,EAAE,IAAI,CAAC;IAE7F,OAAO;MACLjC,QAAQ;MACR2B,QAAQ,EAAEC,IAAI,CAACC,IAAI,CAACI,cAAc,CAAClH,MAAM,GAAG,GAAG,CAAC;MAChD+G,MAAM,EAAE,WAAW;MACnB3B,IAAI,EAAE,CAAC;MACP4B,UAAU,EAAEf,QAAQ,CAACkB,GAAG,CAACC,GAAG,IAAI,GAAGA,GAAG,CAAC/D,OAAO,KAAK+D,GAAG,CAAC7G,IAAI,EAAE,CAAC,CAAC8G,IAAI,CAAC,IAAI;IAC1E,CAAC;EACH;AACF;AAEA,OAAO,MAAMC,aAAa,GAAG,IAAI3H,aAAa,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}