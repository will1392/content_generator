{"ast":null,"code":"// services/ai/gemini.service.ts\nimport axios from 'axios';\nconst GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nconst GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-06-05:generateContent';\nconst GOOGLE_TTS_API_URL = 'https://texttospeech.googleapis.com/v1/text:synthesize';\nexport class GeminiService {\n  async makeRequest(prompt) {\n    console.log('=== GEMINI API REQUEST ===');\n    console.log('API Key exists:', !!GEMINI_API_KEY);\n    console.log('API Key length:', (GEMINI_API_KEY === null || GEMINI_API_KEY === void 0 ? void 0 : GEMINI_API_KEY.length) || 0);\n    console.log('API Key preview:', (GEMINI_API_KEY === null || GEMINI_API_KEY === void 0 ? void 0 : GEMINI_API_KEY.substring(0, 10)) + '...' || 'None');\n    console.log('API URL:', GEMINI_API_URL);\n    console.log('Prompt length:', prompt.length);\n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    try {\n      console.time('Gemini API Call');\n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 4096\n        }\n      };\n      console.log('Request body prepared for Gemini API');\n      const response = await axios.post(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, requestBody, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        timeout: 120000 // 2 minute timeout\n      });\n      console.timeEnd('Gemini API Call');\n      console.log('API response status:', response.status);\n      console.log('API response data keys:', Object.keys(response.data || {}));\n      console.log('Full API response data:', JSON.stringify(response.data, null, 2));\n      if (!response.data) {\n        console.error('Response data is null/undefined');\n        throw new Error('No data in API response');\n      }\n      if (!response.data.candidates || !Array.isArray(response.data.candidates)) {\n        console.error('Missing candidates field in response');\n        console.log('Available fields:', Object.keys(response.data));\n        throw new Error('No candidates field in API response');\n      }\n      if (response.data.candidates.length === 0) {\n        console.error('Candidates array is empty');\n        throw new Error('No candidates in API response');\n      }\n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || !Array.isArray(candidate.content.parts)) {\n        console.error('Invalid candidate structure');\n        console.log('Candidate structure:', JSON.stringify(candidate, null, 2));\n        throw new Error('Invalid candidate content structure');\n      }\n      if (candidate.content.parts.length === 0 || !candidate.content.parts[0].text) {\n        console.error('No text content in candidate');\n        throw new Error('No text content in API response');\n      }\n      const textContent = candidate.content.parts[0].text;\n      console.log('Successfully extracted text, length:', textContent.length);\n      console.log('Text preview:', textContent.substring(0, 200) + '...');\n      return textContent;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3, _error$response4, _error$response5, _error$response6, _error$response7, _error$response9, _error$response9$data, _error$response9$data2;\n      console.error('=== GEMINI API ERROR ===');\n      console.error('Error type:', error.constructor.name);\n      console.error('Error message:', error.message);\n      console.error('Error code:', error.code);\n      console.error('Error status:', (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status);\n      console.error('Error status text:', (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.statusText);\n      console.error('Error response headers:', (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.headers);\n      console.error('Error response data:', JSON.stringify((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data, null, 2));\n      console.error('Is network error:', error.message.includes('Network Error'));\n      console.error('Is timeout:', error.code === 'ECONNABORTED');\n      console.error('Full error stack:', error.stack);\n      console.error('===========================');\n      if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out - please try again');\n      }\n      if (error.message.includes('Network Error')) {\n        throw new Error('Network error connecting to Gemini API. Please check your internet connection.');\n      }\n      if (((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) === 401) {\n        throw new Error('Invalid API key. Please check your Gemini API key configuration.');\n      }\n      if (((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) === 429) {\n        throw new Error('Rate limit exceeded. Please wait a moment and try again.');\n      }\n      if (((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.status) === 400) {\n        var _error$response8, _error$response8$data, _error$response8$data2;\n        throw new Error(`Bad request: ${((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : (_error$response8$data = _error$response8.data) === null || _error$response8$data === void 0 ? void 0 : (_error$response8$data2 = _error$response8$data.error) === null || _error$response8$data2 === void 0 ? void 0 : _error$response8$data2.message) || 'Invalid request format'}`);\n      }\n      const errorMessage = ((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : (_error$response9$data = _error$response9.data) === null || _error$response9$data === void 0 ? void 0 : (_error$response9$data2 = _error$response9$data.error) === null || _error$response9$data2 === void 0 ? void 0 : _error$response9$data2.message) || error.message || 'Failed to generate content';\n      throw new Error(errorMessage);\n    }\n  }\n  async synthesizeSpeech(text, voiceName) {\n    console.log('=== GOOGLE TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Voice:', voiceName);\n    try {\n      const requestBody = {\n        input: {\n          text\n        },\n        voice: {\n          languageCode: 'en-US',\n          name: voiceName,\n          ssmlGender: voiceName.includes('Standard-A') || voiceName.includes('Standard-C') ? 'FEMALE' : 'MALE'\n        },\n        audioConfig: {\n          audioEncoding: 'MP3',\n          speakingRate: 1.0,\n          pitch: 0.0,\n          volumeGainDb: 0.0\n        }\n      };\n      const response = await axios.post(`${GOOGLE_TTS_API_URL}?key=${GEMINI_API_KEY}`, requestBody, {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        timeout: 60000\n      });\n      if (!response.data.audioContent) {\n        throw new Error('No audio content in TTS response');\n      }\n\n      // Convert base64 audio to blob URL\n      const audioBytes = response.data.audioContent;\n      const audioBlob = new Blob([Uint8Array.from(atob(audioBytes), c => c.charCodeAt(0))], {\n        type: 'audio/mp3'\n      });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      console.log('TTS synthesis successful, audio URL created');\n      return audioUrl;\n    } catch (error) {\n      console.error('TTS synthesis failed:', error);\n      throw new Error(`TTS failed: ${error.message}`);\n    }\n  }\n  parseScriptForVoices(script) {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments = [];\n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({\n          speaker,\n          text: text.trim()\n        });\n      }\n    }\n    return segments;\n  }\n  async generateAudio(podcastScript) {\n    var _podcastScript$script;\n    console.log('=== ATTEMPTING REAL AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', ((_podcastScript$script = podcastScript.script) === null || _podcastScript$script === void 0 ? void 0 : _podcastScript$script.length) || 0);\n    console.log('API Key configured:', !!GEMINI_API_KEY);\n    console.log('TTS API URL:', GOOGLE_TTS_API_URL);\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Parse the script to extract speaker segments\n    const segments = this.parseScriptForVoices(podcastScript.script);\n    console.log('Parsed segments:', segments.length);\n    if (segments.length === 0) {\n      // Fallback: treat entire script as single voice\n      console.log('No speaker segments found, using single voice for entire script');\n\n      // Limit script length for testing (Google TTS has character limits)\n      const limitedScript = podcastScript.script.substring(0, 1000);\n      console.log('Using limited script length:', limitedScript.length, 'characters');\n      const audioUrl = await this.synthesizeSpeech(limitedScript, 'en-US-Standard-J');\n      return {\n        audioUrl,\n        duration: Math.ceil(limitedScript.length / 150),\n        // Rough estimate: 150 chars per minute\n        format: 'mp3',\n        size: Math.ceil(limitedScript.length / 10),\n        // Rough estimate\n        transcript: limitedScript\n      };\n    }\n\n    // Generate audio for the first segment only (for testing)\n    console.log('Generating audio for first segment only...');\n    const firstSegment = segments[0];\n    const voiceName = firstSegment.speaker === 'Alex' ? 'en-US-Standard-J' : 'en-US-Standard-I';\n    console.log(`Generating audio for ${firstSegment.speaker}: \"${firstSegment.text.substring(0, 100)}...\"`);\n    console.log('Using voice:', voiceName);\n    const audioUrl = await this.synthesizeSpeech(firstSegment.text, voiceName);\n    return {\n      audioUrl,\n      duration: Math.ceil(firstSegment.text.length / 150),\n      // Rough estimate\n      format: 'mp3',\n      size: Math.ceil(firstSegment.text.length / 10),\n      // Rough estimate\n      transcript: firstSegment.text\n    };\n  }\n}\nexport const geminiService = new GeminiService();","map":{"version":3,"names":["axios","GEMINI_API_KEY","process","env","REACT_APP_GEMINI_API_KEY","GEMINI_API_URL","GOOGLE_TTS_API_URL","GeminiService","makeRequest","prompt","console","log","length","substring","Error","time","requestBody","contents","parts","text","generationConfig","temperature","topK","topP","maxOutputTokens","response","post","headers","timeout","timeEnd","status","Object","keys","data","JSON","stringify","error","candidates","Array","isArray","candidate","content","textContent","_error$response","_error$response2","_error$response3","_error$response4","_error$response5","_error$response6","_error$response7","_error$response9","_error$response9$data","_error$response9$data2","constructor","name","message","code","statusText","includes","stack","_error$response8","_error$response8$data","_error$response8$data2","errorMessage","synthesizeSpeech","voiceName","input","voice","languageCode","ssmlGender","audioConfig","audioEncoding","speakingRate","pitch","volumeGainDb","audioContent","audioBytes","audioBlob","Blob","Uint8Array","from","atob","c","charCodeAt","type","audioUrl","URL","createObjectURL","parseScriptForVoices","script","lines","split","filter","line","trim","segments","match","speaker","push","generateAudio","podcastScript","_podcastScript$script","title","limitedScript","duration","Math","ceil","format","size","transcript","firstSegment","geminiService"],"sources":["/Users/will/Content Creation App/src/services/ai/gemini.service.ts"],"sourcesContent":["// services/ai/gemini.service.ts\nimport axios from 'axios';\nimport { PodcastContent } from '../../types/project.types';\n\nconst GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;\nconst GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-06-05:generateContent';\nconst GOOGLE_TTS_API_URL = 'https://texttospeech.googleapis.com/v1/text:synthesize';\n\nexport interface AudioContent {\n  audioUrl: string;\n  duration: number;\n  format: string;\n  size: number;\n  transcript: string;\n}\n\nexport class GeminiService {\n  private async makeRequest(prompt: string): Promise<string> {\n    console.log('=== GEMINI API REQUEST ===');\n    console.log('API Key exists:', !!GEMINI_API_KEY);\n    console.log('API Key length:', GEMINI_API_KEY?.length || 0);\n    console.log('API Key preview:', GEMINI_API_KEY?.substring(0, 10) + '...' || 'None');\n    console.log('API URL:', GEMINI_API_URL);\n    console.log('Prompt length:', prompt.length);\n    \n    if (!GEMINI_API_KEY) {\n      throw new Error('Gemini API key is not configured. Please add REACT_APP_GEMINI_API_KEY to your .env file.');\n    }\n    \n    try {\n      console.time('Gemini API Call');\n      \n      const requestBody = {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 4096,\n        }\n      };\n      \n      console.log('Request body prepared for Gemini API');\n      \n      const response = await axios.post(\n        `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,\n        requestBody,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          timeout: 120000, // 2 minute timeout\n        }\n      );\n\n      console.timeEnd('Gemini API Call');\n      console.log('API response status:', response.status);\n      console.log('API response data keys:', Object.keys(response.data || {}));\n      console.log('Full API response data:', JSON.stringify(response.data, null, 2));\n      \n      if (!response.data) {\n        console.error('Response data is null/undefined');\n        throw new Error('No data in API response');\n      }\n      \n      if (!response.data.candidates || !Array.isArray(response.data.candidates)) {\n        console.error('Missing candidates field in response');\n        console.log('Available fields:', Object.keys(response.data));\n        throw new Error('No candidates field in API response');\n      }\n      \n      if (response.data.candidates.length === 0) {\n        console.error('Candidates array is empty');\n        throw new Error('No candidates in API response');\n      }\n      \n      const candidate = response.data.candidates[0];\n      if (!candidate.content || !candidate.content.parts || !Array.isArray(candidate.content.parts)) {\n        console.error('Invalid candidate structure');\n        console.log('Candidate structure:', JSON.stringify(candidate, null, 2));\n        throw new Error('Invalid candidate content structure');\n      }\n      \n      if (candidate.content.parts.length === 0 || !candidate.content.parts[0].text) {\n        console.error('No text content in candidate');\n        throw new Error('No text content in API response');\n      }\n      \n      const textContent = candidate.content.parts[0].text;\n      console.log('Successfully extracted text, length:', textContent.length);\n      console.log('Text preview:', textContent.substring(0, 200) + '...');\n      return textContent;\n    } catch (error: any) {\n      console.error('=== GEMINI API ERROR ===');\n      console.error('Error type:', error.constructor.name);\n      console.error('Error message:', error.message);\n      console.error('Error code:', error.code);\n      console.error('Error status:', error.response?.status);\n      console.error('Error status text:', error.response?.statusText);\n      console.error('Error response headers:', error.response?.headers);\n      console.error('Error response data:', JSON.stringify(error.response?.data, null, 2));\n      console.error('Is network error:', error.message.includes('Network Error'));\n      console.error('Is timeout:', error.code === 'ECONNABORTED');\n      console.error('Full error stack:', error.stack);\n      console.error('===========================');\n      \n      if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out - please try again');\n      }\n      \n      if (error.message.includes('Network Error')) {\n        throw new Error('Network error connecting to Gemini API. Please check your internet connection.');\n      }\n      \n      if (error.response?.status === 401) {\n        throw new Error('Invalid API key. Please check your Gemini API key configuration.');\n      }\n      \n      if (error.response?.status === 429) {\n        throw new Error('Rate limit exceeded. Please wait a moment and try again.');\n      }\n      \n      if (error.response?.status === 400) {\n        throw new Error(`Bad request: ${error.response?.data?.error?.message || 'Invalid request format'}`);\n      }\n      \n      const errorMessage = error.response?.data?.error?.message || error.message || 'Failed to generate content';\n      throw new Error(errorMessage);\n    }\n  }\n\n  private async synthesizeSpeech(text: string, voiceName: string): Promise<string> {\n    console.log('=== GOOGLE TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Voice:', voiceName);\n    \n    try {\n      const requestBody = {\n        input: { text },\n        voice: {\n          languageCode: 'en-US',\n          name: voiceName,\n          ssmlGender: voiceName.includes('Standard-A') || voiceName.includes('Standard-C') ? 'FEMALE' : 'MALE'\n        },\n        audioConfig: {\n          audioEncoding: 'MP3',\n          speakingRate: 1.0,\n          pitch: 0.0,\n          volumeGainDb: 0.0\n        }\n      };\n\n      const response = await axios.post(\n        `${GOOGLE_TTS_API_URL}?key=${GEMINI_API_KEY}`,\n        requestBody,\n        {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          timeout: 60000,\n        }\n      );\n\n      if (!response.data.audioContent) {\n        throw new Error('No audio content in TTS response');\n      }\n\n      // Convert base64 audio to blob URL\n      const audioBytes = response.data.audioContent;\n      const audioBlob = new Blob([Uint8Array.from(atob(audioBytes), c => c.charCodeAt(0))], { type: 'audio/mp3' });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      \n      console.log('TTS synthesis successful, audio URL created');\n      return audioUrl;\n    } catch (error: any) {\n      console.error('TTS synthesis failed:', error);\n      throw new Error(`TTS failed: ${error.message}`);\n    }\n  }\n\n  private parseScriptForVoices(script: string): Array<{speaker: string, text: string}> {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments: Array<{speaker: string, text: string}> = [];\n    \n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({ speaker, text: text.trim() });\n      }\n    }\n    \n    return segments;\n  }\n\n  async generateAudio(podcastScript: PodcastContent): Promise<AudioContent> {\n    console.log('=== ATTEMPTING REAL AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', podcastScript.script?.length || 0);\n    console.log('API Key configured:', !!GEMINI_API_KEY);\n    console.log('TTS API URL:', GOOGLE_TTS_API_URL);\n\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Parse the script to extract speaker segments\n    const segments = this.parseScriptForVoices(podcastScript.script);\n    console.log('Parsed segments:', segments.length);\n\n    if (segments.length === 0) {\n      // Fallback: treat entire script as single voice\n      console.log('No speaker segments found, using single voice for entire script');\n      \n      // Limit script length for testing (Google TTS has character limits)\n      const limitedScript = podcastScript.script.substring(0, 1000);\n      console.log('Using limited script length:', limitedScript.length, 'characters');\n      \n      const audioUrl = await this.synthesizeSpeech(limitedScript, 'en-US-Standard-J');\n      \n      return {\n        audioUrl,\n        duration: Math.ceil(limitedScript.length / 150), // Rough estimate: 150 chars per minute\n        format: 'mp3',\n        size: Math.ceil(limitedScript.length / 10), // Rough estimate\n        transcript: limitedScript\n      };\n    }\n\n    // Generate audio for the first segment only (for testing)\n    console.log('Generating audio for first segment only...');\n    const firstSegment = segments[0];\n    const voiceName = firstSegment.speaker === 'Alex' ? 'en-US-Standard-J' : 'en-US-Standard-I';\n    \n    console.log(`Generating audio for ${firstSegment.speaker}: \"${firstSegment.text.substring(0, 100)}...\"`);\n    console.log('Using voice:', voiceName);\n    \n    const audioUrl = await this.synthesizeSpeech(firstSegment.text, voiceName);\n    \n    return {\n      audioUrl,\n      duration: Math.ceil(firstSegment.text.length / 150), // Rough estimate\n      format: 'mp3',\n      size: Math.ceil(firstSegment.text.length / 10), // Rough estimate\n      transcript: firstSegment.text\n    };\n  }\n}\n\nexport const geminiService = new GeminiService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}