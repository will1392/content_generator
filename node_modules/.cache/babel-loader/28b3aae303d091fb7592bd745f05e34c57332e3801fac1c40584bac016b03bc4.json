{"ast":null,"code":"// services/ai/elevenlabs.service.ts\nimport axios from 'axios';\nconst ELEVENLABS_API_KEY = process.env.REACT_APP_ELEVENLABS_API_KEY;\nconst ELEVENLABS_API_URL = 'https://api.elevenlabs.io/v1';\n\n// Pre-defined voice IDs for different characteristics\nconst VOICES = {\n  alex: 'pNInz6obpgDQGcFmaJgB',\n  // Adam - professional male voice\n  jordan: '21m00Tcm4TlvDq8ikWAM',\n  // Rachel - casual female voice (we can use as casual male alternative)\n  default: 'pNInz6obpgDQGcFmaJgB' // Adam as fallback\n};\nexport class ElevenLabsService {\n  async synthesizeSpeech(text, voiceId) {\n    console.log('=== ELEVENLABS TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Voice ID:', voiceId);\n    console.log('API Key exists:', !!ELEVENLABS_API_KEY);\n    if (!ELEVENLABS_API_KEY) {\n      throw new Error('ElevenLabs API key is not configured');\n    }\n    if (!ELEVENLABS_API_KEY.startsWith('sk_')) {\n      throw new Error('Invalid ElevenLabs API key format');\n    }\n    try {\n      const requestBody = {\n        text: text.substring(0, 2500),\n        // Limit text length for free tier\n        model_id: 'eleven_monolingual_v1',\n        voice_settings: {\n          stability: 0.5,\n          similarity_boost: 0.5,\n          style: 0.5,\n          use_speaker_boost: true\n        }\n      };\n      console.log('Making request to ElevenLabs...');\n      const response = await axios.post(`${ELEVENLABS_API_URL}/text-to-speech/${voiceId}`, requestBody, {\n        headers: {\n          'Accept': 'audio/mpeg',\n          'Content-Type': 'application/json',\n          'xi-api-key': ELEVENLABS_API_KEY\n        },\n        responseType: 'arraybuffer',\n        timeout: 30000\n      });\n      console.log('ElevenLabs response received:', response.status);\n      if (!response.data) {\n        throw new Error('No audio data received from ElevenLabs');\n      }\n\n      // Convert array buffer to blob URL\n      const audioBlob = new Blob([response.data], {\n        type: 'audio/mpeg'\n      });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      console.log('Audio blob created successfully');\n      return audioUrl;\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3;\n      console.error('ElevenLabs TTS failed:', error);\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        throw new Error('Invalid ElevenLabs API key');\n      } else if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) {\n        throw new Error('ElevenLabs rate limit exceeded');\n      } else if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 400) {\n        var _error$response4, _error$response4$data;\n        throw new Error(`ElevenLabs bad request: ${((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.detail) || 'Invalid request'}`);\n      }\n      throw new Error(`ElevenLabs TTS failed: ${error.message}`);\n    }\n  }\n  parseScriptForVoices(script) {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments = [];\n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({\n          speaker,\n          text: text.trim()\n        });\n      }\n    }\n    return segments;\n  }\n  async generateAudio(podcastScript) {\n    var _podcastScript$script;\n    console.log('=== ELEVENLABS AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', ((_podcastScript$script = podcastScript.script) === null || _podcastScript$script === void 0 ? void 0 : _podcastScript$script.length) || 0);\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Parse the script to extract speaker segments\n    const segments = this.parseScriptForVoices(podcastScript.script);\n    console.log('Parsed segments:', segments.length);\n    if (segments.length === 0) {\n      // Fallback: treat entire script as single voice\n      console.log('No speaker segments found, using default voice');\n\n      // Limit script length for free tier\n      const limitedScript = podcastScript.script.substring(0, 2500);\n      console.log('Using limited script length:', limitedScript.length, 'characters');\n      const audioUrl = await this.synthesizeSpeech(limitedScript, VOICES.default);\n      return {\n        audioUrl,\n        duration: Math.ceil(limitedScript.length / 150),\n        // Rough estimate\n        format: 'mp3',\n        size: Math.ceil(limitedScript.length / 10),\n        // Rough estimate\n        transcript: limitedScript\n      };\n    }\n\n    // Generate audio for the first segment only (for testing)\n    console.log('Generating audio for first segment...');\n    const firstSegment = segments[0];\n    const voiceId = firstSegment.speaker === 'Alex' ? VOICES.alex : VOICES.jordan;\n    console.log(`Generating audio for ${firstSegment.speaker} using voice ${voiceId}`);\n    console.log(`Text: \"${firstSegment.text.substring(0, 100)}...\"`);\n    const audioUrl = await this.synthesizeSpeech(firstSegment.text, voiceId);\n    return {\n      audioUrl,\n      duration: Math.ceil(firstSegment.text.length / 150),\n      // Rough estimate\n      format: 'mp3',\n      size: Math.ceil(firstSegment.text.length / 10),\n      // Rough estimate\n      transcript: firstSegment.text\n    };\n  }\n}\nexport const elevenLabsService = new ElevenLabsService();","map":{"version":3,"names":["axios","ELEVENLABS_API_KEY","process","env","REACT_APP_ELEVENLABS_API_KEY","ELEVENLABS_API_URL","VOICES","alex","jordan","default","ElevenLabsService","synthesizeSpeech","text","voiceId","console","log","length","Error","startsWith","requestBody","substring","model_id","voice_settings","stability","similarity_boost","style","use_speaker_boost","response","post","headers","responseType","timeout","status","data","audioBlob","Blob","type","audioUrl","URL","createObjectURL","error","_error$response","_error$response2","_error$response3","_error$response4","_error$response4$data","detail","message","parseScriptForVoices","script","lines","split","filter","line","trim","segments","match","speaker","push","generateAudio","podcastScript","_podcastScript$script","title","limitedScript","duration","Math","ceil","format","size","transcript","firstSegment","elevenLabsService"],"sources":["/Users/will/Content Creation App/src/services/ai/elevenlabs.service.ts"],"sourcesContent":["// services/ai/elevenlabs.service.ts\nimport axios from 'axios';\nimport { PodcastContent, AudioContent } from '../../types/project.types';\n\nconst ELEVENLABS_API_KEY = process.env.REACT_APP_ELEVENLABS_API_KEY;\nconst ELEVENLABS_API_URL = 'https://api.elevenlabs.io/v1';\n\n// Pre-defined voice IDs for different characteristics\nconst VOICES = {\n  alex: 'pNInz6obpgDQGcFmaJgB', // Adam - professional male voice\n  jordan: '21m00Tcm4TlvDq8ikWAM', // Rachel - casual female voice (we can use as casual male alternative)\n  default: 'pNInz6obpgDQGcFmaJgB' // Adam as fallback\n};\n\nexport class ElevenLabsService {\n  private async synthesizeSpeech(text: string, voiceId: string): Promise<string> {\n    console.log('=== ELEVENLABS TTS REQUEST ===');\n    console.log('Text length:', text.length);\n    console.log('Voice ID:', voiceId);\n    console.log('API Key exists:', !!ELEVENLABS_API_KEY);\n    \n    if (!ELEVENLABS_API_KEY) {\n      throw new Error('ElevenLabs API key is not configured');\n    }\n\n    if (!ELEVENLABS_API_KEY.startsWith('sk_')) {\n      throw new Error('Invalid ElevenLabs API key format');\n    }\n\n    try {\n      const requestBody = {\n        text: text.substring(0, 2500), // Limit text length for free tier\n        model_id: 'eleven_monolingual_v1',\n        voice_settings: {\n          stability: 0.5,\n          similarity_boost: 0.5,\n          style: 0.5,\n          use_speaker_boost: true\n        }\n      };\n\n      console.log('Making request to ElevenLabs...');\n\n      const response = await axios.post(\n        `${ELEVENLABS_API_URL}/text-to-speech/${voiceId}`,\n        requestBody,\n        {\n          headers: {\n            'Accept': 'audio/mpeg',\n            'Content-Type': 'application/json',\n            'xi-api-key': ELEVENLABS_API_KEY,\n          },\n          responseType: 'arraybuffer',\n          timeout: 30000,\n        }\n      );\n\n      console.log('ElevenLabs response received:', response.status);\n\n      if (!response.data) {\n        throw new Error('No audio data received from ElevenLabs');\n      }\n\n      // Convert array buffer to blob URL\n      const audioBlob = new Blob([response.data], { type: 'audio/mpeg' });\n      const audioUrl = URL.createObjectURL(audioBlob);\n      \n      console.log('Audio blob created successfully');\n      return audioUrl;\n    } catch (error: any) {\n      console.error('ElevenLabs TTS failed:', error);\n      \n      if (error.response?.status === 401) {\n        throw new Error('Invalid ElevenLabs API key');\n      } else if (error.response?.status === 429) {\n        throw new Error('ElevenLabs rate limit exceeded');\n      } else if (error.response?.status === 400) {\n        throw new Error(`ElevenLabs bad request: ${error.response?.data?.detail || 'Invalid request'}`);\n      }\n      \n      throw new Error(`ElevenLabs TTS failed: ${error.message}`);\n    }\n  }\n\n  private parseScriptForVoices(script: string): Array<{speaker: string, text: string}> {\n    const lines = script.split('\\n').filter(line => line.trim());\n    const segments: Array<{speaker: string, text: string}> = [];\n    \n    for (const line of lines) {\n      // Look for speaker patterns like \"Alex:\" or \"Jordan:\"\n      const match = line.match(/^(Alex|Jordan):\\s*(.+)$/);\n      if (match) {\n        const [, speaker, text] = match;\n        segments.push({ speaker, text: text.trim() });\n      }\n    }\n    \n    return segments;\n  }\n\n  async generateAudio(podcastScript: PodcastContent): Promise<AudioContent> {\n    console.log('=== ELEVENLABS AUDIO GENERATION ===');\n    console.log('Podcast title:', podcastScript.title);\n    console.log('Script length:', podcastScript.script?.length || 0);\n\n    if (!podcastScript.script || podcastScript.script.trim().length === 0) {\n      throw new Error('No podcast script provided for audio generation');\n    }\n\n    // Parse the script to extract speaker segments\n    const segments = this.parseScriptForVoices(podcastScript.script);\n    console.log('Parsed segments:', segments.length);\n\n    if (segments.length === 0) {\n      // Fallback: treat entire script as single voice\n      console.log('No speaker segments found, using default voice');\n      \n      // Limit script length for free tier\n      const limitedScript = podcastScript.script.substring(0, 2500);\n      console.log('Using limited script length:', limitedScript.length, 'characters');\n      \n      const audioUrl = await this.synthesizeSpeech(limitedScript, VOICES.default);\n      \n      return {\n        audioUrl,\n        duration: Math.ceil(limitedScript.length / 150), // Rough estimate\n        format: 'mp3',\n        size: Math.ceil(limitedScript.length / 10), // Rough estimate\n        transcript: limitedScript\n      };\n    }\n\n    // Generate audio for the first segment only (for testing)\n    console.log('Generating audio for first segment...');\n    const firstSegment = segments[0];\n    const voiceId = firstSegment.speaker === 'Alex' ? VOICES.alex : VOICES.jordan;\n    \n    console.log(`Generating audio for ${firstSegment.speaker} using voice ${voiceId}`);\n    console.log(`Text: \"${firstSegment.text.substring(0, 100)}...\"`);\n    \n    const audioUrl = await this.synthesizeSpeech(firstSegment.text, voiceId);\n    \n    return {\n      audioUrl,\n      duration: Math.ceil(firstSegment.text.length / 150), // Rough estimate\n      format: 'mp3', \n      size: Math.ceil(firstSegment.text.length / 10), // Rough estimate\n      transcript: firstSegment.text\n    };\n  }\n}\n\nexport const elevenLabsService = new ElevenLabsService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}